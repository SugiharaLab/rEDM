<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>rEDM: An R package for Empirical Dynamic Modeling and Convergent Cross Mapping • rEDM</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="rEDM: An R package for Empirical Dynamic Modeling and Convergent Cross Mapping">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">rEDM</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">0.7.2</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/rEDM-coprediction.html">co-prediction: using rEDM to quantify dynamic similarity</a>
    </li>
    <li>
      <a href="../articles/rEDM-time-delay-ccm.html">Using rEDM to quantify time delays in causation</a>
    </li>
    <li>
      <a href="../articles/rEDM-tutorial.html">rEDM: An R package for Empirical Dynamic Modeling and Convergent Cross Mapping</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/ha0ye/rEDM">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>rEDM: An R package for Empirical Dynamic Modeling and Convergent Cross Mapping</h1>
                        <h4 class="author">Hao Ye</h4>
                        <h4 class="author">Adam Clark</h4>
                        <h4 class="author">Ethan Deyle</h4>
                        <h4 class="author">George Sugihara</h4>
            
            <h4 class="date">2018-09-17</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/ha0ye/rEDM/blob/master/vignettes/rEDM-tutorial.Rmd"><code>vignettes/rEDM-tutorial.Rmd</code></a></small>
      <div class="hidden name"><code>rEDM-tutorial.Rmd</code></div>

    </div>

    
    
<div id="abstract" class="section level1">
<h1 class="hasAnchor">
<a href="#abstract" class="anchor"></a>Abstract</h1>
<p>Empirical dynamic modeling (EDM) is an emerging non-parametric framework for modeling nonlinear dynamic systems. EDM is based on the mathematical theory of recontructing attractor manifolds from time series data <span class="citation">(Takens 1981)</span>. The <strong>rEDM</strong> package collects several EDM methods, including simplex projection <span class="citation">(Sugihara and May 1990)</span>, S-map <span class="citation">(Sugihara 1994)</span>, multivariate embeddings <span class="citation">(Dixon et al. 1999)</span>, convergent cross mapping <span class="citation">(Sugihara et al. 2012)</span>, and multiview embedding <span class="citation">(Ye and Sugihara 2016)</span>. Here, we introduce the basic underlying theory, and describe the functionality of <strong>rEDM</strong>, using examples from both model simulations and real data.</p>
</div>
<div id="introduction" class="section level1">
<h1 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h1>
<p>Many scientific fields use models as approximations of reality and for various purposes (e.g. testing hypotheses regarding mechanisms or processes, explaining past observations, predicting future outcomes). In most cases these models are based on hypothesized parametric equations; however explicit equations can be impractical when the exact mechanisms are unknown or too complex to be characterized with existing datasets. Empirical models, which infer patterns and associations from the data (instead of using hypothesized equations), represent an alternative and highly flexible approach. Here, we review the theoretical background for empirical dynamic modeling (EDM) and the functionality of the <strong>rEDM</strong> package, which are intended for nonlinear dynamic systems that can prove problematic for traditional modeling approaches.</p>
<p>The basic goal underlying EDM is to reconstruct the behavior of dynamic systems using time series data. This approach is based on mathematical theory developed initially by <span class="citation">(Takens 1981)</span>, and subsequently expanded <span class="citation">(Casdagli et al. 1991, Sauer et al. 1991, Deyle and Sugihara 2011)</span>. Because these methods operate with minimal assumptions, they are particularly suitable for studying systems that exhibit non-equilibrium dynamics and nonlinear state-dependent behavior (i.e. where interactions change over time and as a function of the system state).</p>
<div id="installation" class="section level2">
<h2 class="hasAnchor">
<a href="#installation" class="anchor"></a>Installation</h2>
<p>The <strong>rEDM</strong> package can be obtained in two main ways. The standard version of the package can be obtained through CRAN (the Comprehensive R Archive Network): <a href="https://cran.r-project.org/package=rEDM" class="uri">https://cran.r-project.org/package=rEDM</a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">install.packages</span>(<span class="st">"rEDM"</span>)</a></code></pre></div>
<p>However, the most recent version is available on GitHub: <a href="https://github.com/ha0ye/rEDM" class="uri">https://github.com/ha0ye/rEDM</a>, and can be installed using the <code>install_github()</code> function in the <strong>devtools</strong> package.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1">devtools<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/devtools/topics/install_github">install_github</a></span>(<span class="st">"ha0ye/rEDM"</span>)</a></code></pre></div>
</div>
</div>
<div id="empirical-dynamic-modeling" class="section level1">
<h1 class="hasAnchor">
<a href="#empirical-dynamic-modeling" class="anchor"></a>Empirical Dynamic Modeling</h1>
<div id="time-series-as-observations-of-a-dynamic-system" class="section level2">
<h2 class="hasAnchor">
<a href="#time-series-as-observations-of-a-dynamic-system" class="anchor"></a>Time Series as Observations of a Dynamic System</h2>
<p>The essential concept is that time series can be viewed as projections of the behavior of a dynamic system. Here, only a few modest assumptions are required. First, the system state can be described as a point in a high-dimensional space. The axes of this space can be thought of as fundamental state variables; in an ecosystem, these variables might correspond to population abundances, resources, or environmental conditions. Second, the system state changes through time following a set of deterministic rules. In other words, the behavior of the system is not completely stochastic.</p>
<p>Consequently, it is possible to project the system state onto one of the coordinate axes and obtain the value of the corresponding state variable. Sequential projections over time will thus produce a time series for that variable. For example, in the below figure, the states of the canonical Lorenz Attractor <span class="citation">(1963)</span> are projected to the <span class="math inline">\(x\)</span>-axis, creating a time series of variable <span class="math inline">\(x\)</span>.</p>
<div class="figure">
<img src="figure_1.svg" alt="Time Series Projection from the Lorenz Attractor"><p class="caption">Time Series Projection from the Lorenz Attractor</p>
</div>
<p>In simple cases, each time series will represent a different state variable. However, more generally, each time series is an <em>observation function</em> of the system state, and may be a function of several different state variables.</p>
</div>
<div id="attractor-reconstruction-takens-theorem" class="section level2">
<h2 class="hasAnchor">
<a href="#attractor-reconstruction-takens-theorem" class="anchor"></a>Attractor Reconstruction / Takens’ Theorem</h2>
<p>The goal of EDM is to reconstruct the system dynamics from time series data. Because time series are sequential observations of the system behavior, information about the rules that govern system behavior (i.e. the system dynamics) is therefore encoded in the data. Takens’ Theorem <span class="citation">(1981)</span> provides a way to recover this information using just a single time series. Although the system behavior is nominally determined by a high-dimensional state space, we can substitute lags of a time series for any unknown or unobserved variables. For example, instead of representing the system state of the Lorenz Attractor using <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, and <span class="math inline">\(z\)</span>, we can instead use an embedding that consists of <span class="math inline">\(E\)</span> lags of <span class="math inline">\(x\)</span>: <span class="math display">\[ \mathbf{x}_t = \left( x_t, x_{t-\tau}, \dots, x_{t-(E-1)\tau} \right) \]</span></p>
<div class="figure">
<img src="figure_2.svg" alt="Attractor Reconstruction from 3 Lagged Coordinates"><p class="caption">Attractor Reconstruction from 3 Lagged Coordinates</p>
</div>
<p>By Takens’ Theorem, if sufficient lags are used, the reconstruction is a diffeomorphism of the original system. In other words, reconstructed states will map one-to-one to actual system states, and nearby points in the reconstruction will correspond to similar system states. The above figure shows a reconstruction of the Lorenz attractor where the reconstructed system state is comprised of 3 lags of variable <span class="math inline">\(x\)</span>. There is a clear visual correspondence between the reconstruction and the original Lorenz attractor.</p>
<p>There are many applications for using this approach to recover system dynamics from time series. For example, empirical models can be used for forecasting <span class="citation">(Sugihara and May 1990)</span>, to understand nonlinear behavior <span class="citation">(Sugihara 1994)</span>, or to uncover mechanism <span class="citation">(Dixon et al. 1999)</span>. Recent work describes how EDM can be used to identify causal interactions, by testing whether two time series are observed from the same system <span class="citation">(Sugihara et al. 2012)</span>. In the next section, we demonstrate how the <strong>rEDM</strong> software package can be used to accomplish these tasks.</p>
</div>
</div>
<div id="edm-examples" class="section level1">
<h1 class="hasAnchor">
<a href="#edm-examples" class="anchor"></a>EDM Examples</h1>
<div id="nearest-neighbor-forecasting-using-simplex-projection" class="section level2">
<h2 class="hasAnchor">
<a href="#nearest-neighbor-forecasting-using-simplex-projection" class="anchor"></a>Nearest Neighbor Forecasting using Simplex Projection</h2>
<p>As mentioned previously, if enough lags are used, the reconstruction will map one-to-one to the original attractor. However, if the number of lags is insufficient (i.e. the embedding dimension is too small), then the reconstruction will have singularities – points that actually correspond to different system states, but which overlap in the reconstruction. When this occurs, the reconstruction will fail to distinguish between different trajectories, and forecast performance will suffer. Thus, prediction skill can be used as an indicator for the optimal embedding dimension.</p>
<p>In the following example, we demonstrate how to select the embedding dimension. We use a nearest neighbor forecasting method, Simplex Projection <span class="citation">(Sugihara and May 1990)</span>, to produce forecasts, and examine prediction skill, computed as the correlation between observed and predicted values.</p>
<div id="example" class="section level3">
<h3 class="hasAnchor">
<a href="#example" class="anchor"></a>Example</h3>
<p>In this example, time series come from a simulation of the tent map that exhibits chaotic behavior. The tent map is a discrete-time dynamic system, where a sequence, <span class="math inline">\(x_t\)</span>, on the interval <span class="math inline">\([0, 1]\)</span> is iterated according to:</p>
<p><span class="math display">\[\begin{equation*}
x_{t+1} = \begin{cases}
2x_t, &amp; x_t &lt; \frac{1}{2}\\
2(1-x_t), &amp; x_t \ge \frac{1}{2}
\end{cases}
\end{equation*}\]</span></p>
<p>In <strong>rEDM</strong>, a sample time series of the first-differenced values can be found in dataset <code>tentmap_del</code>.</p>
<p>We begin by loading the <strong>rEDM</strong> package:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">library</span>(rEDM)</a></code></pre></div>
<p>Then, we can load the tentmap data:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span>(tentmap_del)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">str</span>(tentmap_del)</a></code></pre></div>
<pre><code>##  num [1:999] -0.0992 -0.6013 0.7998 -0.7944 0.798 ...</code></pre>
<p>We can see that the data consists of a single vector, containing the raw first-differences values of <span class="math inline">\(x_t\)</span>. Because the <code><a href="../reference/simplex.html">simplex()</a></code> function can accept a single vector as the input time series, no further processing of the data is required.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1">ts &lt;-<span class="st"> </span>tentmap_del</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">lib &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">100</span>)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">pred &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">201</span>, <span class="dv">500</span>)</a></code></pre></div>
<p>We begin by initializing the <code>lib</code> and <code>pred</code> variables. These variables define the portions of the data that will be used to create the reconstruction. <code>lib</code> corresponds to the “training” portion of the data, on which nearest neighbors can be identified; and <code>pred</code> corresponds to the “test” portion of the data, on which 1-step ahead forecasts will be made. Here, the first 100 points (positions 1 to 100) in the time series constitute the “library set”, and 300 points (positions 201 to 500) constitute the “prediction set”.</p>
<p>The remaining arguments will be left at their default values (see section “General Parameters” for details). For the <code><a href="../reference/simplex.html">simplex()</a></code> function, this means that the embedding dimension, <span class="math inline">\(E\)</span>, will range from <span class="math inline">\(1\)</span> to <span class="math inline">\(10\)</span>.</p>
<p><em>Note that if the code detects any overlap in the lib and pred, it will prevent a vector from becoming its own neighbor by enabling leave-one-out cross-validation and outputting a warning message.</em></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1">simplex_output &lt;-<span class="st"> </span><span class="kw"><a href="../reference/simplex.html">simplex</a></span>(ts, lib, pred)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="kw">str</span>(simplex_output)</a></code></pre></div>
<pre><code>## 'data.frame':    10 obs. of  16 variables:
##  $ E                  : int  1 2 3 4 5 6 7 8 9 10
##  $ tau                : num  1 1 1 1 1 1 1 1 1 1
##  $ tp                 : num  1 1 1 1 1 1 1 1 1 1
##  $ nn                 : num  2 3 4 5 6 7 8 9 10 11
##  $ num_pred           : num  299 298 297 296 295 294 293 292 291 290
##  $ rho                : num  0.847 0.962 0.942 0.91 0.874 ...
##  $ mae                : num  0.207 0.102 0.138 0.19 0.235 ...
##  $ rmse               : num  0.392 0.187 0.236 0.291 0.334 ...
##  $ perc               : num  0.853 0.906 0.899 0.885 0.824 ...
##  $ p_val              : num  2.59e-102 4.99e-253 4.65e-199 1.54e-151 2.59e-118 ...
##  $ const_pred_num_pred: num  299 298 297 296 295 294 293 292 291 290
##  $ const_pred_rho     : num  -0.668 -0.671 -0.671 -0.673 -0.671 ...
##  $ const_pred_mae     : num  1.02 1.02 1.02 1.02 1.01 ...
##  $ const_pred_rmse    : num  1.25 1.25 1.26 1.26 1.25 ...
##  $ const_pred_perc    : num  0.341 0.339 0.337 0.338 0.339 ...
##  $ const_p_val        : num  1 1 1 1 1 1 1 1 1 1</code></pre>
<p>The output is a data.frame with columns for each of the model parameters and forecast statistics, and rows for each separate model (i.e. different parameter combinations). For Simplex Projection, the model parameters are <code>E</code>, embedding dimension; <code>tau</code>, time lag between successive dimensions; <code>tp</code>, time to prediction; and <code>nn</code>, number of nearest neighbors. The forecast statistics are <code>num_pred</code>, the number of predictions made; <code>rho</code>, Pearson’s correlation coefficient between predictions and observations; <code>mae</code>, mean absolute error of predictions; <code>rmse</code>, root mean squared error of predictions; <code>perc</code>, the percent of predictions that are the same sign as observations; and <code>p_val</code>, the p-value for <code>rho</code> being significantly greater than 0, using Fisher’s transformation <span class="citation">(1915)</span>. For the purpose of comparison, the last 6 columns give those same forecast statistics, but for a naive constant predictor (where the 1-step ahead forecast is the current value) over the same set of predictions.</p>
<p>In this case, there are 10 separate models (one for each value of <code>E</code>), so we can plot <code>E</code> against <code>rho</code> (the correlation between observed and predicted values) to determine the optimal embedding dimension (i.e. the number of dimensions for which the reconstructed attractor is best unfolded, producing the highest forecast skill).</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">par</span>(<span class="dt">mar =</span> <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">1</span>), <span class="dt">mgp =</span> <span class="kw">c</span>(<span class="fl">2.5</span>, <span class="dv">1</span>, <span class="dv">0</span>)) <span class="co"># set margins for plotting</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="kw">plot</span>(simplex_output<span class="op">$</span>E, simplex_output<span class="op">$</span>rho, <span class="dt">type =</span> <span class="st">"l"</span>,  </a>
<a class="sourceLine" id="cb9-3" data-line-number="3">     <span class="dt">xlab =</span> <span class="st">"Embedding Dimension (E)"</span>, <span class="dt">ylab =</span> <span class="st">"Forecast Skill (rho)"</span>)</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/rho%20vs.%20E%20for%20tentmap-1.png" width="480"></p>
<p>Here, we observe that forecast skill peaks at <code>E = 2</code>, indicating that the dynamics of our data are unfolded best in 2 dimensions. <em>Note that this optimal value does not have to correspond to the dimensionality of the original system.</em> The forecast skill will be affected by factors such as observational noise, process error, and time series length, and so it is more useful to think of the embedding dimension as a practical measure that is dependent on properties of the data.</p>
</div>
</div>
<div id="prediction-decay" class="section level2">
<h2 class="hasAnchor">
<a href="#prediction-decay" class="anchor"></a>Prediction Decay</h2>
<p>An important property of many natural systems is that nearby trajectories eventually diverge over time (i.e. “deterministic chaos” – the “butterfly effect”). In essence, this means that while short-term prediction is often possible, information about the state of the system is continually lost over time, hindering long-term prediction. We can demonstrate this effect by examining how prediction skill changes as we increase the <code>tp</code> argument, the “time to prediction”, the number of time steps into the future that forecasts are made.</p>
<div id="example-1" class="section level3">
<h3 class="hasAnchor">
<a href="#example-1" class="anchor"></a>Example</h3>
<p>Using the same data and the <code><a href="../reference/simplex.html">simplex()</a></code> function, we supply a range for the <code>tp</code> argument and fix the embedding dimension to the value determined previously (<code>E = 2</code>):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1">simplex_output &lt;-<span class="st"> </span><span class="kw"><a href="../reference/simplex.html">simplex</a></span>(ts, lib, pred, <span class="dt">E =</span> <span class="dv">2</span>, <span class="dt">tp =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)</a></code></pre></div>
<p>As above, the returned object is a data.frame, so we can examine prediction decay by plotting forecast skill (<code>rho</code>) against the time to prediction (<code>tp</code>).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">plot</span>(simplex_output<span class="op">$</span>tp, simplex_output<span class="op">$</span>rho, <span class="dt">type =</span> <span class="st">"l"</span>,</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">     <span class="dt">xlab =</span> <span class="st">"Time to Prediction (tp)"</span>, <span class="dt">ylab =</span> <span class="st">"Forecast Skill (rho)"</span>)</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/rho%20vs.%20tp%20for%20tentmap-1.png" width="480"></p>
<p>Because the parameters for the tent map fall in the region for chaotic behavior, there is a noticeable decline in forecast skill as <code>tp</code> increases.</p>
</div>
</div>
<div id="identifying-nonlinearity" class="section level2">
<h2 class="hasAnchor">
<a href="#identifying-nonlinearity" class="anchor"></a>Identifying Nonlinearity</h2>
<p>One concern is that time series may show predictability even if they are purely stochastic, because they have temporal autocorrelation (i.e. similar to autocorrelated red noise). We can distinguish between red noise and nonlinear deterministic behavior by using S-maps as described in <span class="citation">(Sugihara 1994)</span>.</p>
<p>In contrast to the nearest-neighbor interpolation of simplex projection, the S-map forecasting method <span class="citation">(Sugihara 1994)</span> fits local linear maps to forecast from the reconstructed state space. Here, “local” means that the map can be different at different locations in the reconstructed state space.</p>
<p>With S-maps, the nonlinear tuning parameter, <span class="math inline">\(\theta\)</span>, determines the strength of the weighting when fitting the lcoal linear map. For example, when <span class="math inline">\(\theta = 0\)</span>, all points always receive equal weighting. In other words, the local linear map does not change, and will be identical to a global linear map – equivalent to fitting an autoregressive model to the data. In contrast, when <span class="math inline">\(\theta &gt; 0\)</span>, nearby points receive larger weights, allowing the local linear map to vary in state-space and accommodate nonlinear behavior (see the “rEDM-algorithms” vignette for more details).</p>
<p>Consequently, if the time series are sampled from autoregressive red noise, then there will be no improvement to forecast skill when <span class="math inline">\(\theta &gt; 0\)</span>. In fact, it is likely that the linear model (<span class="math inline">\(\theta = 0\)</span>) produces the best forecasts, because it uses all the data for constructing the global linear map, thereby reducing the effects of observational noise. Thus, increases in forecast skill when <span class="math inline">\(\theta &gt; 0\)</span> is indicative of nonlinear dynamics; allowing the local linear map to vary in state-space produces a better description of state-dependent behavior.</p>
<div id="example-2" class="section level3">
<h3 class="hasAnchor">
<a href="#example-2" class="anchor"></a>Example</h3>
<p>The S-map method is implemented as the function <code>s_map()</code> in the <strong>rEDM</strong> package. Following from the previous example, we again use the tent map time series, and set <code>E = 2</code> based on the results from simplex projection. Note that we allow many of the arguments to take on default values (e.g., <code>tau = 1</code>, <code>tp = 1</code>). If we had changed these for simplex projection, we would want to propagate them here. The default values for the nonlinear tuning parameter, <code>theta</code>, range from <code>0</code> to <code>8</code>, and are suitable for our purposes.</p>
<p>Note also, that the default value for <code>num_neighbors</code> is <code>0</code>. When using S-maps to test for nonlinear behavior, we want to use all points in the reconstruction, and allow <code>theta</code> to control the weighting assigned to individual points. By using <code>0</code> for this argument (an otherwise nonsensical value), the program will use all nearest neighbors.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1">smap_output &lt;-<span class="st"> </span><span class="kw">s_map</span>(ts, lib, pred, <span class="dt">E =</span> <span class="dv">2</span>)</a></code></pre></div>
<p>Again, the results are a data.frame with columns for each of the model parameters and forecast statistics, with rows for each run of the model. In this case, there is one run for each value of <code>theta</code>, so we can simply plot <code>theta</code> against <code>rho</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">plot</span>(smap_output<span class="op">$</span>theta, smap_output<span class="op">$</span>rho, <span class="dt">type =</span> <span class="st">"l"</span>,</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">     <span class="dt">xlab =</span> <span class="st">"Nonlinearity (theta)"</span>, <span class="dt">ylab =</span> <span class="st">"Forecast Skill (rho)"</span>)</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/rho%20vs.%20theta%20for%20tentmap-1.png" width="480"></p>
<p>Here, we can see that forecast skill substantially improves as <code>theta</code> increases, indicating the presence of nonlinear dynamics. Typically, we would expect forecast skill to begin to decrease at high values of <code>theta</code>, because the local linear map will overfit to the nearest points. However, because the example data are observed without any noise, we continue to get a better approximation to the true function with higher <code>theta</code>.</p>
<p>By simulating the addition of a small amount of observational noise, a plot more typical of real data can be achieved:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1">ts_err &lt;-<span class="st"> </span>ts <span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(<span class="kw">length</span>(ts), <span class="dt">sd =</span> <span class="kw">sd</span>(ts) <span class="op">*</span><span class="st"> </span><span class="fl">0.2</span>)</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">smap_output_err &lt;-<span class="st"> </span><span class="kw">s_map</span>(ts_err, lib, pred, <span class="dt">E =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="kw">plot</span>(smap_output_err<span class="op">$</span>theta, smap_output_err<span class="op">$</span>rho, <span class="dt">type =</span> <span class="st">"l"</span>,</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">     <span class="dt">xlab =</span> <span class="st">"Nonlinearity (theta)"</span>, <span class="dt">ylab =</span> <span class="st">"Forecast Skill (rho)"</span>)</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/rho%20vs.%20theta%20with%20noise-1.png" width="480"></p>
</div>
</div>
<div id="generalized-takenss-theorem" class="section level2">
<h2 class="hasAnchor">
<a href="#generalized-takenss-theorem" class="anchor"></a>Generalized Takens’s Theorem</h2>
<p>In addition to creating an attractor from lags of one time series, it is possible to combine different time series, if they are all observed from the same system <span class="citation">(Sauer et al. 1991, Deyle and Sugihara 2011)</span>. The practical reality of complex dynamics, finite, noisy data, and stochastic drivers means that “multivariate” reconstructions can often be a better description than “univariate” reconstructions.</p>
<p>In <strong>rEDM</strong>, the <code><a href="../reference/block_lnlp.html">block_lnlp()</a></code> function generalizes the <code><a href="../reference/simplex.html">simplex()</a></code> and <code>s_map()</code> functions: reconstructions can be formed from any set of coordinates, and forecasts are made using either of the two methods.</p>
<p>The data format for <code><a href="../reference/block_lnlp.html">block_lnlp()</a></code> is a matrix or data.frame, where each column is a separate time series, and each row is a temporal “slice” of the data comprised of simultaneous observations. A reconstruction is defined by specifying which columns to use as coordinates (the <code>columns</code> argument) and which column is to be forecast (the <code>target_column</code> argument). If lagged copies of a time series are desired as coordinates, they need to be pre-computed as separate columns in the input (e.g. via the <code><a href="../reference/make_block.html">make_block()</a></code> function).</p>
<div id="example-3" class="section level3">
<h3 class="hasAnchor">
<a href="#example-3" class="anchor"></a>Example</h3>
<p>We begin by loading an example dataset from a coupled 3-species model system.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">data</span>(block_3sp)</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="kw">str</span>(block_3sp)</a></code></pre></div>
<pre><code>## 'data.frame':    200 obs. of  10 variables:
##  $ time : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ x_t  : num  -0.742 1.245 -1.918 -0.962 1.332 ...
##  $ x_t-1: num  NA -0.742 1.245 -1.918 -0.962 ...
##  $ x_t-2: num  NA NA -0.742 1.245 -1.918 ...
##  $ y_t  : num  -1.268 1.489 -0.113 -1.107 2.385 ...
##  $ y_t-1: num  NA -1.268 1.489 -0.113 -1.107 ...
##  $ y_t-2: num  NA NA -1.268 1.489 -0.113 ...
##  $ z_t  : num  -1.864 -0.482 1.535 -1.493 -1.119 ...
##  $ z_t-1: num  NA -1.864 -0.482 1.535 -1.493 ...
##  $ z_t-2: num  NA NA -1.864 -0.482 1.535 ...</code></pre>
<p>Here, the <code>block_3sp</code> variable is a 10-column data.frame with 1 column for time, and 3 columns for each of the variables (unlagged: <span class="math inline">\(t\)</span>, lag-1: <span class="math inline">\(t-1\)</span>, and lag-2: <span class="math inline">\(t-2\)</span>). Note that the lagged columns begin with <code>NA</code> values because there are no observations of the variables for times <span class="math inline">\(t &lt; 1\)</span>. The vectors that include <code>NA</code> values are excluded if that specific value is needed for computation (see section “Data Input” for more details).</p>
<p>Columns can be referred to using either numerical indices or the column names. If numerical indices are used, <code>block_lnlp</code> has an option to indicate that the first column is actually a time index. When <code>first_column_time</code> is set to <code>TRUE</code>, a value of <code>1</code> for <code>target_column</code> will point to the first <em>data</em> column in the data.frame.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" data-line-number="1">lib &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="kw">NROW</span>(block_3sp))</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">pred &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="kw">NROW</span>(block_3sp))</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">cols &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">target &lt;-<span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6"></a>
<a class="sourceLine" id="cb17-7" data-line-number="7">block_lnlp_output &lt;-<span class="st"> </span><span class="kw"><a href="../reference/block_lnlp.html">block_lnlp</a></span>(block_3sp, <span class="dt">lib =</span> lib, <span class="dt">pred =</span> pred,</a>
<a class="sourceLine" id="cb17-8" data-line-number="8">                                <span class="dt">columns =</span> cols, <span class="dt">target_column =</span> target,</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">                                <span class="dt">stats_only =</span> <span class="ot">FALSE</span>, <span class="dt">first_column_time =</span> <span class="ot">TRUE</span>, </a>
<a class="sourceLine" id="cb17-10" data-line-number="10">                                <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<p>We can also refer to columns by the column names. This ignores the <code>first_column_time</code> argument when referring to columns, but does use the time column to label predictions:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" data-line-number="1">block_lnlp_output_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw"><a href="../reference/block_lnlp.html">block_lnlp</a></span>(block_3sp, <span class="dt">lib =</span> lib, <span class="dt">pred =</span> pred,</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">                                  <span class="dt">columns =</span> <span class="kw">c</span>(<span class="st">"x_t"</span>, <span class="st">"x_t-1"</span>, <span class="st">"y_t"</span>), <span class="dt">target_column =</span> <span class="st">"x_t"</span>,</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">                                  <span class="dt">stats_only =</span> <span class="ot">FALSE</span>, <span class="dt">first_column_time =</span> <span class="ot">TRUE</span>, </a>
<a class="sourceLine" id="cb18-4" data-line-number="4">                                  <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb18-5" data-line-number="5"></a>
<a class="sourceLine" id="cb18-6" data-line-number="6"><span class="co"># test for equality</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7"><span class="kw">stopifnot</span>(<span class="kw">identical</span>(block_lnlp_output, block_lnlp_output_<span class="dv">2</span>))</a></code></pre></div>
<p>Note that the default value for the <code>tp</code> argument is <code>1</code>, indicating that predictions are 1-step ahead (i.e. using each row of the <code>columns</code> variables to predict the subsequent row of the <code>target_column</code> variable). <em>In some cases, the data may be formatted to have the predicted variable aligned in the same row (but in a different column), and <code>tp</code> should be set to <code>0</code>.</em></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">str</span>(block_lnlp_output)</a></code></pre></div>
<pre><code>## 'data.frame':    1 obs. of  16 variables:
##  $ embedding          : chr "1, 2, 4"
##  $ tp                 : num 1
##  $ nn                 : num 4
##  $ num_pred           : num 198
##  $ rho                : num 0.875
##  $ mae                : num 0.32
##  $ rmse               : num 0.43
##  $ perc               : num 0.889
##  $ p_val              : num 6.83e-80
##  $ const_pred_num_pred: num 198
##  $ const_pred_rho     : num -0.539
##  $ const_pred_mae     : num 1.31
##  $ const_pred_rmse    : num 1.55
##  $ const_pred_perc    : num 0.394
##  $ const_p_val        : num 1
##  $ model_output       :List of 1
##   ..$ :'data.frame': 200 obs. of  4 variables:
##   .. ..$ time    : num  2 3 4 5 6 7 8 9 10 11 ...
##   .. ..$ obs     : num  1.245 -1.918 -0.962 1.332 -0.817 ...
##   .. ..$ pred    : num  NaN -1.226 -0.657 0.872 -1.59 ...
##   .. ..$ pred_var: num  NaN 0.328 0.522 0.236 0.244 ...
##   ..- attr(*, "class")= chr "AsIs"</code></pre>
<p>By setting <code>stats_only</code> to <code>FALSE</code>, the output also includes the observed and predicted values in a list column (<code>model_output</code>). Unlike other columns, which are vectors of simple types (e.g. numeric, character), the <code>model_output</code> column is a list of length 1, whose single element is a data.frame of the observed and predicted values. If we had run multiple models, the <code>model_output</code> column would be a list of multiple data.frames (one data.frame of observed and predicted values for each model).</p>
<p>To compare the observed and predicted values, we want to pull out the appropriate columns:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb21-1" data-line-number="1">list_of_model_predictions &lt;-<span class="st"> </span>block_lnlp_output<span class="op">$</span>model_output</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">first_data_frame_of_predictions &lt;-<span class="st"> </span>list_of_model_predictions[[<span class="dv">1</span>]]</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">observed &lt;-<span class="st"> </span>first_data_frame_of_predictions<span class="op">$</span>obs</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">predicted &lt;-<span class="st"> </span>first_data_frame_of_predictions<span class="op">$</span>pred</a></code></pre></div>
<p>We can compare predicted vs. observed in a square plot with a 1:1 line.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" data-line-number="1">plot_range &lt;-<span class="st"> </span><span class="kw">range</span>(<span class="kw">c</span>(observed, predicted), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="kw">plot</span>(observed, predicted, <span class="dt">xlim =</span> plot_range, <span class="dt">ylim =</span> plot_range,</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">     <span class="dt">xlab =</span> <span class="st">"Observed"</span>, <span class="dt">ylab =</span> <span class="st">"Predicted"</span>, <span class="dt">asp =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb22-4" data-line-number="4"><span class="kw">abline</span>(<span class="dt">a =</span> <span class="dv">0</span>, <span class="dt">b =</span> <span class="dv">1</span>, <span class="dt">lty =</span> <span class="dv">2</span>, <span class="dt">col =</span> <span class="st">"blue"</span>)</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/observed%20vs%20predicted%20for%20block_lnlp-1.png" width="384"></p>
</div>
</div>
<div id="s-map-coefficients" class="section level2">
<h2 class="hasAnchor">
<a href="#s-map-coefficients" class="anchor"></a>S-map Coefficients</h2>
<p>As described in <span class="citation">(Deyle et al. 2016)</span>, the S-map coefficients from the appropriate multivariate embedding can be interpreted as dynamic, time-varying interaction strengths. We demonstrate this approach for the same 3-species simulation as above, using <code>x</code>, <code>y</code>, and <code>z</code> as the coordinates to predict <code>x</code>.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">data</span>(block_3sp)</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">lib &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">100</span>)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">pred &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">101</span>, <span class="dv">200</span>)</a>
<a class="sourceLine" id="cb23-4" data-line-number="4"></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">cols &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">"x_t"</span>, <span class="st">"y_t"</span>, <span class="st">"z_t"</span>)</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">target &lt;-<span class="st"> "x_t"</span></a>
<a class="sourceLine" id="cb23-7" data-line-number="7"></a>
<a class="sourceLine" id="cb23-8" data-line-number="8">block_smap_output &lt;-<span class="st"> </span><span class="kw"><a href="../reference/block_lnlp.html">block_lnlp</a></span>(block_3sp, <span class="dt">lib =</span> lib, <span class="dt">pred =</span> pred,</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">                                <span class="dt">columns =</span> cols, <span class="dt">target_column =</span> target, </a>
<a class="sourceLine" id="cb23-10" data-line-number="10">                                <span class="dt">method =</span> <span class="st">"s-map"</span>, <span class="dt">theta =</span> <span class="dv">2</span>, </a>
<a class="sourceLine" id="cb23-11" data-line-number="11">                                <span class="dt">stats_only =</span> <span class="ot">FALSE</span>, <span class="dt">first_column_time =</span> <span class="ot">TRUE</span>, </a>
<a class="sourceLine" id="cb23-12" data-line-number="12">                                <span class="dt">save_smap_coefficients =</span> <span class="ot">TRUE</span>, <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<p>The <code>smap_coefficients</code> column of the output is a list-column with the data.frames for the S-map coefficients of each model. Since we have just have one model, we just want the first element of that list. The result is a data.frame with 200 rows (for each prediction) and 4 columns (for each of the 3 predictors and a constant).</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" data-line-number="1">smap_coeffs &lt;-<span class="st"> </span>block_smap_output<span class="op">$</span>smap_coefficients[[<span class="dv">1</span>]]</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="kw">str</span>(smap_coeffs)</a></code></pre></div>
<pre><code>## 'data.frame':    100 obs. of  4 variables:
##  $ c_1: num  -1.561 0.394 -1.112 -0.801 -1.487 ...
##  $ c_2: num  -0.2263 0.0216 -0.164 0.0315 -0.1408 ...
##  $ c_3: num  -0.34154 0.12711 -0.22768 0.03366 0.00995 ...
##  $ c_0: num  0.63 0.668 0.397 0.388 0.555 ...</code></pre>
<p>Here, we plot the time series for the observed (solid) and predicted (dashed) values of <code>x</code> in the top panel; and the inferred interactions (s-map coefficients) for the influence of <code>x</code>, <code>y</code>, and <code>z</code> on future values of <code>x</code> in the remaining 3 panels.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb26-1" data-line-number="1">predictions &lt;-<span class="st"> </span>block_smap_output<span class="op">$</span>model_output[[<span class="dv">1</span>]]</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">t &lt;-<span class="st"> </span>predictions<span class="op">$</span>time</a>
<a class="sourceLine" id="cb26-3" data-line-number="3"></a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="kw">plot</span>(t, predictions<span class="op">$</span>obs, <span class="dt">type =</span> <span class="st">"l"</span>, <span class="dt">col =</span> <span class="st">"black"</span>, <span class="dt">ylab =</span> <span class="st">"x"</span>, <span class="dt">xlab =</span> <span class="st">""</span>)</a>
<a class="sourceLine" id="cb26-5" data-line-number="5"><span class="kw">lines</span>(t, predictions<span class="op">$</span>pred, <span class="dt">lty =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb26-6" data-line-number="6"><span class="kw">legend</span>(<span class="st">"topright"</span>, <span class="dt">legend =</span> <span class="kw">c</span>(<span class="st">"observed"</span>, <span class="st">"predicted"</span>), <span class="dt">lty =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="dt">bty =</span> <span class="st">"n"</span>)</a>
<a class="sourceLine" id="cb26-7" data-line-number="7"></a>
<a class="sourceLine" id="cb26-8" data-line-number="8"><span class="kw">plot</span>(t, smap_coeffs[, <span class="dv">1</span>], <span class="dt">type =</span> <span class="st">"l"</span>, <span class="dt">col =</span> <span class="st">"red"</span>, <span class="dt">ylab =</span> <span class="st">"effect of x"</span>, <span class="dt">xlab =</span> <span class="st">""</span>)</a>
<a class="sourceLine" id="cb26-9" data-line-number="9"><span class="kw">plot</span>(t, smap_coeffs[, <span class="dv">2</span>], <span class="dt">type =</span> <span class="st">"l"</span>, <span class="dt">col =</span> <span class="st">"blue"</span>, <span class="dt">ylab =</span> <span class="st">"effect of y"</span>, <span class="dt">xlab =</span> <span class="st">""</span>)</a>
<a class="sourceLine" id="cb26-10" data-line-number="10"><span class="kw">plot</span>(t, smap_coeffs[, <span class="dv">3</span>], <span class="dt">type =</span> <span class="st">"l"</span>, <span class="dt">col =</span> <span class="st">"magenta"</span>, <span class="dt">ylab =</span> <span class="st">"effect of z"</span>, <span class="dt">xlab =</span> <span class="st">""</span>)</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/smap%20coefficients%20plot-1.png" width="576"></p>
</div>
<div id="gaussian-process" class="section level2">
<h2 class="hasAnchor">
<a href="#gaussian-process" class="anchor"></a>Gaussian Process</h2>
<p>An alternative approach to using Simplex Projection or S-maps is to use Gaussian Processes (GP). In the <strong>rEDM</strong> package, the equivalent function to the univariate <code><a href="../reference/simplex.html">simplex()</a></code> and <code>s_map()</code> is <code><a href="../reference/tde_gp.html">tde_gp()</a></code> (for “Time Delay Embedding using Gaussian Processes”) and the equivalent function to the general <code><a href="../reference/block_lnlp.html">block_lnlp()</a></code> is <code><a href="../reference/block_gp.html">block_gp()</a></code>.</p>
<p>Note that the arguments are slightly different: the GP formulation includes hyperparameters for fitting to the data (<code>phi</code>, <code>v_e</code>, and <code>eta</code>). These can be set directly, or fit over the points in the <code>lib</code> portion of the data. In addition, the GP specifies not only pointwise error estimates for the predicted points, but also the covariance between them. In other words, the uncertainty for nearby points, in the state-space of the reconstructed attractor, is correlated. Setting <code>save_covariance_matrix = TRUE</code> will also return the full covariance matrix for the predicted points in the output of these functions. For more details, please see the documentation for <code><a href="../reference/tde_gp.html">tde_gp()</a></code> and <code><a href="../reference/block_gp.html">block_gp()</a></code>.</p>
<p>We repeat the above example, but using <code><a href="../reference/block_gp.html">block_gp()</a></code> instead of <code><a href="../reference/block_lnlp.html">block_lnlp()</a></code>.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">data</span>(block_3sp)</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">lib &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="kw">NROW</span>(block_3sp))</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">pred &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="kw">NROW</span>(block_3sp))</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">cols &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">target &lt;-<span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6"></a>
<a class="sourceLine" id="cb27-7" data-line-number="7">block_gp_output &lt;-<span class="st"> </span><span class="kw"><a href="../reference/block_gp.html">block_gp</a></span>(block_3sp, <span class="dt">lib =</span> lib, <span class="dt">pred =</span> pred,</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">                              <span class="dt">columns =</span> cols, <span class="dt">target_column =</span> target,</a>
<a class="sourceLine" id="cb27-9" data-line-number="9">                              <span class="dt">stats_only =</span> <span class="ot">FALSE</span>, <span class="dt">first_column_time =</span> <span class="ot">TRUE</span>, </a>
<a class="sourceLine" id="cb27-10" data-line-number="10">                              <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb27-11" data-line-number="11"></a>
<a class="sourceLine" id="cb27-12" data-line-number="12"><span class="kw">str</span>(block_gp_output)</a></code></pre></div>
<pre><code>## 'data.frame':    1 obs. of  13 variables:
##  $ embedding   : Factor w/ 1 level "1, 2, 4": 1
##  $ tp          : num 1
##  $ phi         : num 0.289
##  $ v_e         : num -2.03
##  $ eta         : num 2.01
##  $ fit_params  : logi TRUE
##  $ num_pred    : num 198
##  $ rho         : num 0.949
##  $ mae         : num 0.214
##  $ rmse        : num 0.281
##  $ perc        : num 0.924
##  $ p_val       : num 2.15e-142
##  $ model_output:List of 1
##   ..$ :'data.frame': 198 obs. of  4 variables:
##   .. ..$ time    : num  3 4 5 6 7 8 9 10 11 12 ...
##   .. ..$ obs     : num  -1.918 -0.962 1.332 -0.817 0.744 ...
##   .. ..$ pred    : num  -1.376 -0.888 1.063 -1.097 0.959 ...
##   .. ..$ pred_var: num  0.114 0.112 0.128 0.147 0.107 ...</code></pre>
<p>The output is nearly identical to that of <code><a href="../reference/block_lnlp.html">block_lnlp()</a></code>, but with slightly different columns - the GP hyperparameters are included instead of the number of neighbors and <code>theta</code> parameters.</p>
<p>To compare the observed and predicted values, we can again use the data.frame from the <code>model_output</code> column:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb29-1" data-line-number="1">gp_predictions &lt;-<span class="st"> </span>block_gp_output<span class="op">$</span>model_output[[<span class="dv">1</span>]]</a>
<a class="sourceLine" id="cb29-2" data-line-number="2"></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">plot_range &lt;-<span class="st"> </span><span class="kw">range</span>(<span class="kw">c</span>(gp_predictions<span class="op">$</span>obs, gp_predictions<span class="op">$</span>pred), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb29-4" data-line-number="4"><span class="kw">plot</span>(gp_predictions<span class="op">$</span>obs, gp_predictions<span class="op">$</span>pred, <span class="dt">xlim =</span> plot_range, <span class="dt">ylim =</span> plot_range,</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">     <span class="dt">xlab =</span> <span class="st">"Observed"</span>, <span class="dt">ylab =</span> <span class="st">"Predicted"</span>, <span class="dt">asp =</span> <span class="dv">1</span>, <span class="dt">pch =</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb29-6" data-line-number="6"><span class="kw">abline</span>(<span class="dt">a =</span> <span class="dv">0</span>, <span class="dt">b =</span> <span class="dv">1</span>, <span class="dt">lty =</span> <span class="dv">2</span>, <span class="dt">col =</span> <span class="st">"blue"</span>)</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/predicted%20vs%20observed%20for%20block_gp-1.png" width="384"></p>
</div>
<div id="multiview-embedding" class="section level2">
<h2 class="hasAnchor">
<a href="#multiview-embedding" class="anchor"></a>Multiview Embedding</h2>
<p>The generality of Taken’s Theorem means that in situations with multivariate time series, there can often be many different, valid attractor reconstructions. As described in <span class="citation">(Ye and Sugihara 2016)</span>, combining these different models can result in improved forecasts.</p>
<p>Here, we demonstrate this idea using the <code><a href="../reference/multiview.html">multiview()</a></code> function and with the same dataset as above. <code><a href="../reference/multiview.html">multiview()</a></code> operates by constructing all possible embeddings of dimension <code>E</code>, with lag up to <code>max_lag</code> (and excluding embeddings that don’t have at least one coordinate with 0 time lag). These embeddings are ranked by forecast skill (<code>rho</code>) over the <code>lib</code> portion of the data. The individual forecasts for the top <code>k</code> embeddings are then averaged together.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">data</span>(<span class="st">"block_3sp"</span>)</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">block &lt;-<span class="st"> </span>block_3sp[, <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">8</span>)] <span class="co"># use only the unlagged time series</span></a>
<a class="sourceLine" id="cb30-3" data-line-number="3"></a>
<a class="sourceLine" id="cb30-4" data-line-number="4">lib &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="kw">floor</span>(<span class="kw">NROW</span>(block_3sp) <span class="op">/</span><span class="st"> </span><span class="dv">2</span>))</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">pred &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">floor</span>(<span class="kw">NROW</span>(block_3sp) <span class="op">/</span><span class="st"> </span><span class="dv">2</span>) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>, <span class="kw">NROW</span>(block_3sp))</a>
<a class="sourceLine" id="cb30-6" data-line-number="6"></a>
<a class="sourceLine" id="cb30-7" data-line-number="7"><span class="co"># multiple values for `k` can be provided, </span></a>
<a class="sourceLine" id="cb30-8" data-line-number="8"><span class="co">#   "sqrt" uses floor(sqrt(m)), where m is the number of embeddings</span></a>
<a class="sourceLine" id="cb30-9" data-line-number="9">k_list &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="st">"sqrt"</span>, <span class="st">"all"</span>)</a>
<a class="sourceLine" id="cb30-10" data-line-number="10"></a>
<a class="sourceLine" id="cb30-11" data-line-number="11">multiview_output &lt;-<span class="st"> </span><span class="kw"><a href="../reference/multiview.html">multiview</a></span>(block, <span class="dt">lib =</span> lib, <span class="dt">pred =</span> pred,</a>
<a class="sourceLine" id="cb30-12" data-line-number="12">                              <span class="dt">E =</span> <span class="dv">3</span>, <span class="dt">max_lag =</span> <span class="dv">3</span>, </a>
<a class="sourceLine" id="cb30-13" data-line-number="13">                              <span class="dt">k =</span> k_list, <span class="dt">target_column =</span> <span class="dv">1</span>, </a>
<a class="sourceLine" id="cb30-14" data-line-number="14">                              <span class="dt">stats_only =</span> <span class="ot">FALSE</span>, </a>
<a class="sourceLine" id="cb30-15" data-line-number="15">                              <span class="dt">save_lagged_block =</span> <span class="ot">TRUE</span>, </a>
<a class="sourceLine" id="cb30-16" data-line-number="16">                              <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb30-17" data-line-number="17"></a>
<a class="sourceLine" id="cb30-18" data-line-number="18"><span class="kw">str</span>(multiview_output, <span class="dt">max.level =</span> <span class="dv">1</span>)</a></code></pre></div>
<pre><code>## 'data.frame':    4 obs. of  14 variables:
##  $ E           : num  3 3 3 3
##  $ tau         : num  1 1 1 1
##  $ tp          : num  1 1 1 1
##  $ nn          : num  4 4 4 4
##  $ k           : num  1 3 8 64
##  $ num_pred    : num  99 99 99 99
##  $ rho         : num  0.846 0.902 0.908 0.851
##  $ mae         : num  0.351 0.272 0.259 0.373
##  $ rmse        : num  0.459 0.354 0.34 0.469
##  $ perc        : num  0.848 0.899 0.939 0.919
##  $ p_val       : num  2.00e-34 2.96e-48 2.26e-50 3.12e-35
##  $ model_output:List of 4
##   ..- attr(*, "class")= chr "AsIs"
##  $ lagged_block:List of 4
##   ..- attr(*, "class")= chr "AsIs"
##  $ embeddings  :List of 4</code></pre>
<p>Note that the output has information about 3 models, since we specified 3 different values for <code>k</code>. Here, <code>lagged_block</code> gives the block that includes lags constructed for multiview embedding, and <code>embeddings</code> gives the list of the embeddings that were averaged together for each model.</p>
<p>Again, we can compare the observed and predicted values using the data.frame from the <code>model_output</code> column:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>)</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    predictions &lt;-<span class="st"> </span>multiview_output<span class="op">$</span>model_output[[i]]</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">    </a>
<a class="sourceLine" id="cb32-5" data-line-number="5">    plot_range &lt;-<span class="st"> </span><span class="kw">range</span>(<span class="kw">c</span>(predictions<span class="op">$</span>obs, predictions<span class="op">$</span>pred), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb32-6" data-line-number="6">    <span class="kw">plot</span>(predictions<span class="op">$</span>obs, predictions<span class="op">$</span>pred, <span class="dt">xlim =</span> plot_range, <span class="dt">ylim =</span> plot_range,</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">         <span class="dt">xlab =</span> <span class="st">"Observed"</span>, <span class="dt">ylab =</span> <span class="st">"Predicted"</span>, <span class="dt">asp =</span> <span class="dv">1</span>, </a>
<a class="sourceLine" id="cb32-8" data-line-number="8">         <span class="dt">main =</span> <span class="kw">paste0</span>(multiview_output<span class="op">$</span>k[i], <span class="st">" embeddings"</span>))</a>
<a class="sourceLine" id="cb32-9" data-line-number="9">    <span class="kw">abline</span>(<span class="dt">a =</span> <span class="dv">0</span>, <span class="dt">b =</span> <span class="dv">1</span>, <span class="dt">lty =</span> <span class="dv">2</span>, <span class="dt">col =</span> <span class="st">"blue"</span>)</a>
<a class="sourceLine" id="cb32-10" data-line-number="10">}</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/predicted%20vs%20observed%20for%20multiview-1.png" width="576"></p>
</div>
<div id="causality-inference-and-cross-mapping" class="section level2">
<h2 class="hasAnchor">
<a href="#causality-inference-and-cross-mapping" class="anchor"></a>Causality Inference and Cross Mapping</h2>
<p>One of the corollaries to Takens’ Theorem is that multiple reconstructions not only map to the original system, but also to each other. Consider two variables, <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> that interact in a dynamic system. The univariate reconstructions based on lags of <span class="math inline">\(x\)</span> (<span class="math inline">\(\mathbf{M}_x\)</span>) or <span class="math inline">\(y\)</span> (<span class="math inline">\(\mathbf{M}_y\)</span>) are each capable of uniquely identifying system states. Thus, the reconstructed states of <span class="math inline">\(\mathbf{M}_x\)</span> map to reconstructed states of <span class="math inline">\(\mathbf{M}_y\)</span>. This suggests a way to test whether <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> interact in the same system, by testing for a mapping between <span class="math inline">\(\mathbf{M}_x\)</span> and <span class="math inline">\(\mathbf{M}_y\)</span>. Practically this is done by testing the predictive skill for the mapping from <span class="math inline">\(\mathbf{M}_x\)</span> to <span class="math inline">\(y\)</span> and from <span class="math inline">\(\mathbf{M}_y\)</span> to <span class="math inline">\(x\)</span>.</p>
<div class="figure">
<img src="figure_3.svg" alt="Cross Mapping Between Reconstructions of the Lorenz Attractor"><p class="caption">Cross Mapping Between Reconstructions of the Lorenz Attractor</p>
</div>
<p>Furthermore, in the case of unidirectional causality, e.g. <span class="math inline">\(x\)</span> causes <span class="math inline">\(y\)</span>, but <span class="math inline">\(y\)</span> does not cause <span class="math inline">\(x\)</span>, we would only expect cross mapping to be successful in one direction. Somewhat counterintuitively, if a causal variable (<span class="math inline">\(x\)</span>) leaves a signature on the affected variable (<span class="math inline">\(y\)</span>), then it is possible to map from <span class="math inline">\(\mathbf{M}_y\)</span> to <span class="math inline">\(\mathbf{M}_x\)</span>, but not vice-versa.</p>
<p>In essence, <span class="math inline">\(\mathbf{M}_y\)</span> must have complete information about <span class="math inline">\(y\)</span>, which means it must include information about all its causes, including <span class="math inline">\(x\)</span>. However, because <span class="math inline">\(x\)</span> behaves independently of <span class="math inline">\(y\)</span>, the reconstruction <span class="math inline">\(\mathbf{M}_x\)</span> may be missing information about <span class="math inline">\(y\)</span>, preventing a <em>complete</em> cross mapping from <span class="math inline">\(\mathbf{M}_x\)</span> to <span class="math inline">\(y\)</span>.</p>
<p>To be more precise, although <span class="math inline">\(x\)</span> has incomplete information about <span class="math inline">\(y\)</span>, it does have a causal influence on <span class="math inline">\(y\)</span>, and there will likely be some predictive skill in the mapping from <span class="math inline">\(\mathbf{M}_x\)</span> to <span class="math inline">\(y\)</span>. However, this will be limited to the statistical association between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> and will generally not improve with more data.</p>
<p>In contrast, the mapping from <span class="math inline">\(\mathbf{M}_y\)</span> to <span class="math inline">\(x\)</span> is expected to become complete with more data. This convergence is a critical property for inferring causality, and can be tested by measuring the cross mapping skill when using different amounts of data to reconstruct <span class="math inline">\(\mathbf{M}_y\)</span>. For a more detailed description of using cross mapping to infer causation, see <span class="citation">(Sugihara et al. 2012, Ye et al. 2015)</span>.</p>
</div>
<div id="convergent-cross-mapping-ccm" class="section level2">
<h2 class="hasAnchor">
<a href="#convergent-cross-mapping-ccm" class="anchor"></a>Convergent Cross Mapping (CCM)</h2>
<p>In <strong>rEDM</strong>, convergent cross mapping is implemented as the <code><a href="../reference/ccm.html">ccm()</a></code> function, which provides a wrapper to compute cross map skill for different subsamples of the data. In the following example, we reproduce the analysis from <span class="citation">(Sugihara et al. 2012)</span> to identify causality between anchovy landings in California and Newport Pier sea-surface temperature. For this example, we use the previously identified embedding dimension of <code>E = 3</code>.</p>
<p>To identify convergence, we compute cross-map skill (Pearson’s correlation, <span class="math inline">\(\rho\)</span> between observed and predicted values) over many random subsamples of the time series. The <code>lib_sizes</code> argument specifies the size of the library set, and <code>num_samples</code> specifies the number of subsamples generated at each library size. <code>random_libs</code> and <code>replace</code> specify how the subsamples will be generated. Here, setting both to <code>TRUE</code> enables random sampling with replacement.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="kw">data</span>(sardine_anchovy_sst)</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">anchovy_xmap_sst &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm.html">ccm</a></span>(sardine_anchovy_sst, <span class="dt">E =</span> <span class="dv">3</span>,</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">                        <span class="dt">lib_column =</span> <span class="st">"anchovy"</span>, <span class="dt">target_column =</span> <span class="st">"np_sst"</span>,</a>
<a class="sourceLine" id="cb33-4" data-line-number="4">                        <span class="dt">lib_sizes =</span> <span class="kw">seq</span>(<span class="dv">10</span>, <span class="dv">80</span>, <span class="dt">by =</span> <span class="dv">10</span>), <span class="dt">num_samples =</span> <span class="dv">100</span>,</a>
<a class="sourceLine" id="cb33-5" data-line-number="5">                        <span class="dt">random_libs =</span> <span class="ot">TRUE</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>, <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb33-6" data-line-number="6">sst_xmap_anchovy &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm.html">ccm</a></span>(sardine_anchovy_sst, <span class="dt">E =</span> <span class="dv">3</span>,</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">                        <span class="dt">lib_column =</span> <span class="st">"np_sst"</span>, <span class="dt">target_column =</span> <span class="st">"anchovy"</span>,</a>
<a class="sourceLine" id="cb33-8" data-line-number="8">                        <span class="dt">lib_sizes =</span> <span class="kw">seq</span>(<span class="dv">10</span>, <span class="dv">80</span>, <span class="dt">by =</span> <span class="dv">10</span>), <span class="dt">num_samples =</span> <span class="dv">100</span>,</a>
<a class="sourceLine" id="cb33-9" data-line-number="9">                        <span class="dt">random_libs =</span> <span class="ot">TRUE</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>, <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb33-10" data-line-number="10"><span class="kw">str</span>(anchovy_xmap_sst)</a></code></pre></div>
<pre><code>## 'data.frame':    800 obs. of  11 variables:
##  $ E            : num  3 3 3 3 3 3 3 3 3 3 ...
##  $ tau          : num  1 1 1 1 1 1 1 1 1 1 ...
##  $ tp           : num  0 0 0 0 0 0 0 0 0 0 ...
##  $ nn           : num  4 4 4 4 4 4 4 4 4 4 ...
##  $ lib_column   : Factor w/ 1 level "anchovy": 1 1 1 1 1 1 1 1 1 1 ...
##  $ target_column: Factor w/ 1 level "np_sst": 1 1 1 1 1 1 1 1 1 1 ...
##  $ lib_size     : num  10 10 10 10 10 10 10 10 10 10 ...
##  $ num_pred     : num  76 76 76 76 76 76 76 76 76 76 ...
##  $ rho          : num  0.0426 -0.0902 0.0277 -0.1224 0.0415 ...
##  $ mae          : num  0.882 1.01 0.868 0.88 0.843 ...
##  $ rmse         : num  1.08 1.3 1.05 1.12 1.05 ...</code></pre>
<p>The output is a data.frame with statistics for each model run (in this case, 100 models at each of 8 library sizes). To interpret the results, we aggregate the cross map performance at each library size using the <code><a href="../reference/ccm_means.html">ccm_means()</a></code> function, which computes a mean value at each unique <code>lib_size</code>. Because average cross map skill less than 0 means there is no prediction skill, (predictions should not be anticorrelated with observations), we set negative values to 0 when plotting.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb35-1" data-line-number="1">a_xmap_t_means &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm_means.html">ccm_means</a></span>(anchovy_xmap_sst)</a>
<a class="sourceLine" id="cb35-2" data-line-number="2">t_xmap_a_means &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm_means.html">ccm_means</a></span>(sst_xmap_anchovy)</a>
<a class="sourceLine" id="cb35-3" data-line-number="3"></a>
<a class="sourceLine" id="cb35-4" data-line-number="4"><span class="kw">plot</span>(a_xmap_t_means<span class="op">$</span>lib_size, <span class="kw">pmax</span>(<span class="dv">0</span>, a_xmap_t_means<span class="op">$</span>rho), <span class="dt">type =</span> <span class="st">"l"</span>, <span class="dt">col =</span> <span class="st">"red"</span>,</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">     <span class="dt">xlab =</span> <span class="st">"Library Size"</span>, <span class="dt">ylab =</span> <span class="st">"Cross Map Skill (rho)"</span>, <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">0.25</span>))</a>
<a class="sourceLine" id="cb35-6" data-line-number="6"><span class="kw">lines</span>(t_xmap_a_means<span class="op">$</span>lib_size, <span class="kw">pmax</span>(<span class="dv">0</span>, t_xmap_a_means<span class="op">$</span>rho), <span class="dt">col =</span> <span class="st">"blue"</span>)</a>
<a class="sourceLine" id="cb35-7" data-line-number="7"><span class="kw">legend</span>(<span class="dt">x =</span> <span class="st">"topleft"</span>, <span class="dt">legend =</span> <span class="kw">c</span>(<span class="st">"anchovy xmap SST"</span>, <span class="st">"SST xmap anchovy"</span>),</a>
<a class="sourceLine" id="cb35-8" data-line-number="8">       <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">"red"</span>, <span class="st">"blue"</span>), <span class="dt">lwd =</span> <span class="dv">1</span>, <span class="dt">bty =</span> <span class="st">"n"</span>, <span class="dt">inset =</span> <span class="fl">0.02</span>, <span class="dt">cex =</span> <span class="fl">0.8</span>)</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/sardine%20anchovy%20ccm%20plot-1.png" width="480"></p>
</div>
<div id="time-delays-with-ccm" class="section level2">
<h2 class="hasAnchor">
<a href="#time-delays-with-ccm" class="anchor"></a>Time Delays with CCM</h2>
<p>By default, the <code><a href="../reference/ccm.html">ccm()</a></code> function identifies a causal effect of <span class="math inline">\(x\)</span> on <span class="math inline">\(y\)</span> by computing a mapping between lagged-coordinate vectors of the affected variable, <span class="math inline">\(y\)</span>, and the simultaneous value of the causal variable, <span class="math inline">\(y\)</span>: <span class="math display">\[ x_{t+tp} = F\left(\mathbf{y}_t\right) = F\left(y_t, y_{t-\tau}, \dots, y_{t-(E-1)\tau} \right) \]</span> where <code>tp = 0</code>.</p>
<p>However, <code>tp</code> is an argument to <code><a href="../reference/ccm.html">ccm()</a></code>, and accepts both positive and negative values. This allows us to determine the value of <code>tp</code> that produces the best mapping for <span class="math inline">\(F\)</span>. This is, to a first approximation, the time delay by which information about <span class="math inline">\(y\)</span> is encoded in the time series of <span class="math inline">\(x\)</span> <span class="citation">(see Ye et al. 2015 for more information)</span>.</p>
<p>Note that negative values of <code>tp</code> (<span class="math inline">\(tp &lt; 0\)</span>) correspond to estimating the <em>past</em> values of <span class="math inline">\(x\)</span> using the reconstructed states of <span class="math inline">\(\mathbf{y}\)</span>. This suggests that the dynamical signal appears first in <span class="math inline">\(x\)</span> and later in <span class="math inline">\(y\)</span>, and is consistent with <span class="math inline">\(x\)</span> causing <span class="math inline">\(y\)</span>, becauses causes must precede effects.</p>
<p>If there is no causation in the reverse direction (i.e. <span class="math inline">\(y\)</span> does not cause <span class="math inline">\(x\)</span>), then the reconstructed states of <span class="math inline">\(\mathbf{x}\)</span> should best predict future values of <span class="math inline">\(y\)</span> and we would expect CCM skill in the opposite direction: <span class="math display">\[ y_{t+tp} = G\left(\mathbf{x}_t\right) = G\left(x_t, x_{t-\tau}, \dots, x_{t-(E-1)\tau} \right) \]</span> would be highest at a positive value of <code>tp</code> (<span class="math inline">\(tp &gt; 0\)</span>).</p>
<p>In general, this presumes that the time series are sampled frequently enough such that the causal effect occurs over more than one observation in time. If causation is synchronous, or nearly so given the data, then the optimal value of <code>tp</code> may be <span class="math inline">\(0\)</span> in both directions.</p>
<div id="example-4" class="section level3">
<h3 class="hasAnchor">
<a href="#example-4" class="anchor"></a>Example</h3>
<p>First, we use time series of <em>Paramecium</em> and <em>Didinium</em> from the classical predator-prey experient:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">data</span>(paramecium_didinium)</a>
<a class="sourceLine" id="cb36-2" data-line-number="2"><span class="kw">str</span>(paramecium_didinium)</a></code></pre></div>
<pre><code>## 'data.frame':    71 obs. of  3 variables:
##  $ time      : num  0 0.52 1.01 1.54 2.04 2.51 3 3.46 3.97 4.5 ...
##  $ paramecium: num  15.7 53.6 73.3 93.9 115.4 ...
##  $ didinium  : num  5.76 9.05 17.26 41.97 55.97 ...</code></pre>
<p>We next setup the cross mapping runs we want to do:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb38-1" data-line-number="1">vars &lt;-<span class="st"> </span><span class="kw">names</span>(paramecium_didinium)[<span class="dv">2</span><span class="op">:</span><span class="dv">3</span>] <span class="co"># c("paramecium", "didinium")</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2"></a>
<a class="sourceLine" id="cb38-3" data-line-number="3"><span class="co"># generate all combinations of lib_column, target_column, tp</span></a>
<a class="sourceLine" id="cb38-4" data-line-number="4">params &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">lib_column =</span> vars,</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">                      <span class="dt">target_column =</span> vars,</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">                      <span class="dt">tp =</span> <span class="dv">-10</span><span class="op">:</span><span class="dv">10</span>)</a>
<a class="sourceLine" id="cb38-7" data-line-number="7"></a>
<a class="sourceLine" id="cb38-8" data-line-number="8"><span class="co"># throw out cases where lib == target</span></a>
<a class="sourceLine" id="cb38-9" data-line-number="9">params &lt;-<span class="st"> </span>params[params<span class="op">$</span>lib_column <span class="op">!=</span><span class="st"> </span>params<span class="op">$</span>target_column, ]</a></code></pre></div>
<p>For the embedding dimension, we use <code>E = 3</code>, which is optimal or very close to optimal for both variables. In other cases, the <code>E</code> would be set to the best univariate embedding dimension for each <code>lib_column</code> variable:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb39-1" data-line-number="1">params<span class="op">$</span>E &lt;-<span class="st"> </span><span class="dv">3</span></a></code></pre></div>
<p>We can determine the optimal values of <code>tp</code> by testing different values, and using as much data as possible in order to obtain the cleanest signal:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb40-1" data-line-number="1">output &lt;-<span class="st"> </span><span class="kw">do.call</span>(rbind, <span class="kw">lapply</span>(<span class="kw">seq_len</span>(<span class="kw">NROW</span>(params)), <span class="cf">function</span>(i) {</a>
<a class="sourceLine" id="cb40-2" data-line-number="2">    <span class="kw"><a href="../reference/ccm.html">ccm</a></span>(paramecium_didinium, <span class="dt">E =</span> params<span class="op">$</span>E[i],</a>
<a class="sourceLine" id="cb40-3" data-line-number="3">        <span class="dt">lib_sizes =</span> <span class="kw">NROW</span>(paramecium_didinium), <span class="dt">random_libs =</span> <span class="ot">FALSE</span>,</a>
<a class="sourceLine" id="cb40-4" data-line-number="4">        <span class="dt">lib_column =</span> params<span class="op">$</span>lib_column[i],</a>
<a class="sourceLine" id="cb40-5" data-line-number="5">        <span class="dt">target_column =</span> params<span class="op">$</span>target_column[i],</a>
<a class="sourceLine" id="cb40-6" data-line-number="6">        <span class="dt">tp =</span> params<span class="op">$</span>tp[i], <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb40-7" data-line-number="7">}))</a></code></pre></div>
<p>Add an additional column to the output for the direction of the cross mapping, and then plot the results:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb41-1" data-line-number="1">output<span class="op">$</span>direction &lt;-<span class="st"> </span><span class="kw">paste</span>(output<span class="op">$</span>lib_column, <span class="st">"xmap to</span><span class="ch">\n</span><span class="st">"</span>, output<span class="op">$</span>target_column)</a>
<a class="sourceLine" id="cb41-2" data-line-number="2"></a>
<a class="sourceLine" id="cb41-3" data-line-number="3"><span class="kw">library</span>(ggplot2)</a>
<a class="sourceLine" id="cb41-4" data-line-number="4">time_delay_ccm_fig &lt;-<span class="st"> </span><span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/ggplot">ggplot</a></span>(output, <span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/aes">aes</a></span>(<span class="dt">x =</span> tp, <span class="dt">y =</span> rho, <span class="dt">color =</span> direction)) <span class="op">+</span></a>
<a class="sourceLine" id="cb41-5" data-line-number="5"><span class="st">    </span><span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/geom_path">geom_line</a></span>() <span class="op">+</span><span class="st"> </span><span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/ggtheme">theme_bw</a></span>()</a></code></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="kw">print</span>(time_delay_ccm_fig)</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/unnamed-chunk-17-1.png" width="480"></p>
<p>As expected for this simple predator-prey system, we see evidence for causation in both directions (cross map skill, <code>rho</code>, peaks for negative <code>tp</code>). Using cross map skill as a proxy for interaction strength (under the assumption that all else is equal, which is reasonable for this laboratory experiment), it looks like the causal interaction is equally strong in both directions. We further note that the estimated time delay for the effect of predators (<em>Didinium</em>) on prey (<em>Paramecium</em>) is fast (<code>tp = -1</code> for “paramecium xmap to didinium”) compared to the effect of prey on predators (<code>tp = -4</code> for “didinium xmap to paramecium”). This is consistent with the ecological interpretation that changes in predator abundance affect prey abundance quickly, while there is a lag in the response of predator abundance to changes in prey abundance.</p>
</div>
</div>
</div>
<div id="real-data-examples" class="section level1">
<h1 class="hasAnchor">
<a href="#real-data-examples" class="anchor"></a>Real Data Examples</h1>
<div id="community-productivity-and-invasibility" class="section level2">
<h2 class="hasAnchor">
<a href="#community-productivity-and-invasibility" class="anchor"></a>Community Productivity and Invasibility</h2>
<p>The data presented here are part of Experiment 120, the “Big Biodiversity” experiment at Cedar Creek LTER <span class="citation">(Tilman et al. 1997)</span>. The full data and metadata are available at <a href="http://www.cedarcreek.umn.edu/research/data" class="uri">http://www.cedarcreek.umn.edu/research/data</a>. This experiment is the longest running randomized test for the effects of plant diversity on ecosystem functions. Plots were established in 1994 and planted with 1, 2, 4, 8, or 16 species, and are sampled annually for above-ground plant biomass. The most well-known result from the experiment is that the number of planted species has strong positive effects on above-ground biomass production. However, because the diversity treatments are weeded annually to prevent non-planted species from establishing (i.e. species richness is not allowed to vary dynamically), this well-known result does not lend itself to EDM.</p>
<p>Instead, we focus on a different set of published results from the experiment: interactions between primary productivity, soil nitrate, and invasion rates. Increased biomass is associated with decreases in soil nitrate levels and decreases in invasion success <span class="citation">(Fargione and Tilman 2005)</span>. A posited mechanism is that increased primary productivity leads to decreased soil nitrate, which in turn reduces resources available to invaders. In order to increase sample size, we combine data from the treatments with 16 planted species, which have almost identical planted compositions and follow similar dynamics. We then analyze these different plots together as spatial replicates, similar to Hsieh et al. <span class="citation">(2008)</span> and Clark et al. <span class="citation">(2015)</span>.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="kw">data</span>(e120_invnit16)</a>
<a class="sourceLine" id="cb43-2" data-line-number="2"><span class="kw">str</span>(e120_invnit16)</a></code></pre></div>
<pre><code>## 'data.frame':    238 obs. of  7 variables:
##  $ Exp             : int  120 120 120 120 120 120 120 120 120 120 ...
##  $ Year            : int  1996 1997 1998 1999 2001 2002 1996 1997 1998 1999 ...
##  $ Plot            : int  9 9 9 9 9 9 27 27 27 27 ...
##  $ AbvBioAnnProd   : num  182 266 259 324 282 ...
##  $ noh020tot       : num  0.1217 0.0643 0.0948 0.0579 0.0294 ...
##  $ invrichness     : int  14 10 12 9 3 4 14 7 6 6 ...
##  $ SummerPrecip.mm.: num  448 446 356 488 357 ...</code></pre>
<p>The columns in the dataset <code>e120_invnit16</code> are as follows: <code>Exp</code> indicates the experiment code, <code>Year</code> shows the sampling time; <code>Plot</code> describes plot identity; <code>AbvBioAnnProd</code> shows annual above-ground productivity of planted species, in g/m<span class="math inline">\(^2\)</span>; <code>noh020tot</code> shows soil nitrate levels in the top 20 cm of soil, measured in mg/kg soil; <code>invrichness</code> shows species richness of unplanted species in the plot (i.e. weeds); <code>SummerPrecip.mm.</code> shows precipitation annual from May to August measured in mm.</p>
<div id="preparing-the-data" class="section level3">
<h3 class="hasAnchor">
<a href="#preparing-the-data" class="anchor"></a>Preparing the Data</h3>
<p>The data come from multiple plots, meaning that we first need to construct a single composite time series. We begin by normalizing each time series to mean zero and standard deviation one. This facilitates mixing multiple spatial replicates in a single analyses in EDM.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb45-1" data-line-number="1">normalize &lt;-<span class="st"> </span><span class="cf">function</span>(x, ...) {(x <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(x, ...))<span class="op">/</span><span class="kw">sd</span>(x, ...)}</a>
<a class="sourceLine" id="cb45-2" data-line-number="2"></a>
<a class="sourceLine" id="cb45-3" data-line-number="3"><span class="co"># separate time column from data</span></a>
<a class="sourceLine" id="cb45-4" data-line-number="4">vars &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">"AbvBioAnnProd"</span>, <span class="st">"noh020tot"</span>, <span class="st">"invrichness"</span>, <span class="st">"SummerPrecip.mm."</span>)</a>
<a class="sourceLine" id="cb45-5" data-line-number="5">composite_ts &lt;-<span class="st"> </span>e120_invnit16[, vars]</a>
<a class="sourceLine" id="cb45-6" data-line-number="6"></a>
<a class="sourceLine" id="cb45-7" data-line-number="7"><span class="co"># normalize each time series within a plot</span></a>
<a class="sourceLine" id="cb45-8" data-line-number="8">data_by_plot &lt;-<span class="st"> </span><span class="kw">split</span>(composite_ts, e120_invnit16<span class="op">$</span>Plot)</a>
<a class="sourceLine" id="cb45-9" data-line-number="9">normalized_data &lt;-<span class="st"> </span><span class="kw">lapply</span>(data_by_plot, <span class="cf">function</span>(df) <span class="kw">sapply</span>(df, normalize))</a>
<a class="sourceLine" id="cb45-10" data-line-number="10">composite_ts &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="dt">Year =</span> e120_invnit16<span class="op">$</span>Year,</a>
<a class="sourceLine" id="cb45-11" data-line-number="11">                      <span class="kw">data.frame</span>(<span class="kw">do.call</span>(rbind, normalized_data)))</a></code></pre></div>
<p>To prevent lagged vectors from being constructed that span separate plots, we need to create an appropriate index variable to identify different segments. We can then assess the predictive skill of EDM by using cross-validation and selecting random subsets of plots to use for the library and prediction sets.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb46-1" data-line-number="1">segments_end &lt;-<span class="st"> </span><span class="kw">cumsum</span>(<span class="kw">sapply</span>(data_by_plot, NROW))</a>
<a class="sourceLine" id="cb46-2" data-line-number="2">segments_begin &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, segments_end[<span class="op">-</span><span class="kw">length</span>(segments_end)] <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb46-3" data-line-number="3">segments &lt;-<span class="st"> </span><span class="kw">cbind</span>(segments_begin, segments_end)</a>
<a class="sourceLine" id="cb46-4" data-line-number="4"></a>
<a class="sourceLine" id="cb46-5" data-line-number="5"><span class="co"># Choose random segments for prediction</span></a>
<a class="sourceLine" id="cb46-6" data-line-number="6"><span class="kw">set.seed</span>(<span class="dv">2312</span>)</a>
<a class="sourceLine" id="cb46-7" data-line-number="7">rndlib &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">NROW</span>(segments), <span class="kw">floor</span>(<span class="kw">NROW</span>(segments) <span class="op">*</span><span class="st"> </span><span class="fl">0.75</span>))</a>
<a class="sourceLine" id="cb46-8" data-line-number="8">composite_lib &lt;-<span class="st"> </span>segments[rndlib, ]</a>
<a class="sourceLine" id="cb46-9" data-line-number="9">composite_pred &lt;-<span class="st"> </span>segments[<span class="op">-</span>rndlib, ]</a></code></pre></div>
<p>Because precipitation is measured for the site and is identical across all the plots, we want to avoid duplication of the data. However, this means that the time series for precipitation is just 7 points, which is too short to characterize any dynamics. Thus, we exclude it from the following simplex and S-map analysis.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb47-1" data-line-number="1">precip_ts &lt;-<span class="st"> </span><span class="kw">unique</span>(e120_invnit16[, <span class="kw">c</span>(<span class="st">"Year"</span>, <span class="st">"SummerPrecip.mm."</span>)])</a>
<a class="sourceLine" id="cb47-2" data-line-number="2">precip_ts &lt;-<span class="st"> </span>precip_ts[<span class="kw">order</span>(precip_ts<span class="op">$</span>Year), ]</a>
<a class="sourceLine" id="cb47-3" data-line-number="3"><span class="kw">NROW</span>(precip_ts)</a></code></pre></div>
<pre><code>## [1] 7</code></pre>
</div>
<div id="quantifying-predictability-and-nonlinearity" class="section level3">
<h3 class="hasAnchor">
<a href="#quantifying-predictability-and-nonlinearity" class="anchor"></a>Quantifying predictability and nonlinearity</h3>
<p>We first use the <strong>rEDM</strong> function, <code><a href="../reference/simplex.html">simplex()</a></code> to identify the best embedding dimension for biomass, nitrate, and invader richness.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb49-1" data-line-number="1">vars &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">"AbvBioAnnProd"</span>, <span class="st">"noh020tot"</span>, <span class="st">"invrichness"</span>)</a>
<a class="sourceLine" id="cb49-2" data-line-number="2">simplex_out &lt;-<span class="st"> </span><span class="kw">lapply</span>(vars, </a>
<a class="sourceLine" id="cb49-3" data-line-number="3">                      <span class="cf">function</span>(var) {</a>
<a class="sourceLine" id="cb49-4" data-line-number="4">                          <span class="kw"><a href="../reference/simplex.html">simplex</a></span>(composite_ts[, <span class="kw">c</span>(<span class="st">"Year"</span>, var)], <span class="dt">E =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">4</span>, </a>
<a class="sourceLine" id="cb49-5" data-line-number="5">                                  <span class="dt">lib =</span> composite_lib, <span class="dt">pred =</span> composite_pred)</a>
<a class="sourceLine" id="cb49-6" data-line-number="6">                      })</a>
<a class="sourceLine" id="cb49-7" data-line-number="7"><span class="kw">names</span>(simplex_out) &lt;-<span class="st"> </span>vars</a>
<a class="sourceLine" id="cb49-8" data-line-number="8"></a>
<a class="sourceLine" id="cb49-9" data-line-number="9"><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>))</a>
<a class="sourceLine" id="cb49-10" data-line-number="10"><span class="cf">for</span> (var <span class="cf">in</span> <span class="kw">names</span>(simplex_out))</a>
<a class="sourceLine" id="cb49-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb49-12" data-line-number="12">    <span class="kw">plot</span>(simplex_out[[var]]<span class="op">$</span>E, simplex_out[[var]]<span class="op">$</span>rho, <span class="dt">type =</span> <span class="st">"l"</span>, </a>
<a class="sourceLine" id="cb49-13" data-line-number="13">         <span class="dt">xlab =</span> <span class="st">"Embedding Dimension (E)"</span>, <span class="dt">ylab =</span> <span class="st">"Forecast Skill (rho)"</span>, </a>
<a class="sourceLine" id="cb49-14" data-line-number="14">         <span class="dt">main =</span> var)</a>
<a class="sourceLine" id="cb49-15" data-line-number="15">}</a>
<a class="sourceLine" id="cb49-16" data-line-number="16"></a>
<a class="sourceLine" id="cb49-17" data-line-number="17">best_E &lt;-<span class="st"> </span><span class="kw">sapply</span>(simplex_out, <span class="cf">function</span>(df) {df<span class="op">$</span>E[<span class="kw">which.max</span>(df<span class="op">$</span>rho)]})</a>
<a class="sourceLine" id="cb49-18" data-line-number="18">best_E</a></code></pre></div>
<pre><code>## AbvBioAnnProd     noh020tot   invrichness 
##             4             3             4</code></pre>
<p><img src="rEDM-tutorial_files/figure-html/simplex%20on%20e120-1.png" width="576"></p>
<p>Note that for two variables (aboveground biomass and invader richness), the best embedding dimension is also the maximum that we test. These results suggest that the dynamics could be high-dimensional, or that our results might be biased because of the limited time series length for each segment. Collecting longer time series would be beneficial to enable better predictions and more clearly distinguish between these possibilities.</p>
<p>Using these values for the embedding dimension, we can identify nonlinearity using the <code>s_map()</code> function:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb51-1" data-line-number="1">smap_out &lt;-<span class="st"> </span><span class="kw">lapply</span>(vars, </a>
<a class="sourceLine" id="cb51-2" data-line-number="2">                   <span class="cf">function</span>(var) {</a>
<a class="sourceLine" id="cb51-3" data-line-number="3">                       <span class="kw">s_map</span>(composite_ts[, <span class="kw">c</span>(<span class="st">"Year"</span>, var)], <span class="dt">E =</span> best_E[var], </a>
<a class="sourceLine" id="cb51-4" data-line-number="4">                             <span class="dt">lib =</span> composite_lib, <span class="dt">pred =</span> composite_pred)</a>
<a class="sourceLine" id="cb51-5" data-line-number="5">                   })</a>
<a class="sourceLine" id="cb51-6" data-line-number="6"><span class="kw">names</span>(smap_out) &lt;-<span class="st"> </span><span class="kw">names</span>(simplex_out)</a>
<a class="sourceLine" id="cb51-7" data-line-number="7"></a>
<a class="sourceLine" id="cb51-8" data-line-number="8"><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>))</a>
<a class="sourceLine" id="cb51-9" data-line-number="9"><span class="cf">for</span> (var <span class="cf">in</span> <span class="kw">names</span>(smap_out))</a>
<a class="sourceLine" id="cb51-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb51-11" data-line-number="11">    <span class="kw">plot</span>(smap_out[[var]]<span class="op">$</span>theta, smap_out[[var]]<span class="op">$</span>rho, <span class="dt">type =</span> <span class="st">"l"</span>, </a>
<a class="sourceLine" id="cb51-12" data-line-number="12">         <span class="dt">xlab =</span> <span class="st">"Nonlinearity (theta)"</span>, <span class="dt">ylab =</span> <span class="st">"Forecast Skill (rho)"</span>, </a>
<a class="sourceLine" id="cb51-13" data-line-number="13">         <span class="dt">main =</span> var)</a>
<a class="sourceLine" id="cb51-14" data-line-number="14">}</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/smap%20on%20e120-1.png" width="576"></p>
<p>Note that aboveground biomass and invader richness suggest nonlinear dynamics in the data (because of the initial increase in forecast skill for <code>theta &gt; 0</code>, followed by a gradual drop-off). However, the monotonic decrease in <code>rho</code> for <code>theta &gt; 0</code> for <code>noh020tot</code> suggests that soil nitrate levels may have only linear dynamics.</p>
</div>
<div id="multivariate-models" class="section level3">
<h3 class="hasAnchor">
<a href="#multivariate-models" class="anchor"></a>Multivariate Models</h3>
<p>Our next step is to produce forecast models. Recall that biomass was best predicted using the maximum number of available time lags. As such, it could be that adding additional information from other variables will improve predictions. Specifically, we compare models that predict aboveground biomass using lags of itself vs. models that also include precipitation as a predictor.</p>
<p>We can do this using the <code><a href="../reference/block_lnlp.html">block_lnlp()</a></code> function, but first we need to construct lags for each variable. Here, we use the <code><a href="../reference/make_block.html">make_block()</a></code> function, which automatically adds lags of the variables. However, we also need to be careful, since the raw data combines observations from multiple plots. By including the <code>lib</code> argument, we can indicate which parts of the time series correspond to different segments, so that lags indicate unknown values correctly.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb52-1" data-line-number="1">block_data &lt;-<span class="st"> </span><span class="kw"><a href="../reference/make_block.html">make_block</a></span>(composite_ts[, <span class="dv">2</span><span class="op">:</span><span class="dv">5</span>], <span class="dt">t =</span> composite_ts<span class="op">$</span>Year, </a>
<a class="sourceLine" id="cb52-2" data-line-number="2">                         <span class="dt">max_lag =</span> <span class="dv">4</span>, <span class="dt">lib =</span> segments)</a>
<a class="sourceLine" id="cb52-3" data-line-number="3"><span class="kw">str</span>(block_data)</a></code></pre></div>
<pre><code>## 'data.frame':    238 obs. of  17 variables:
##  $ time              : num  1996 1997 1998 1999 2001 ...
##  $ AbvBioAnnProd     : num  -1.4518 -0.2581 -0.3576 0.5574 -0.0345 ...
##  $ AbvBioAnnProd_1   : num  NA -1.452 -0.258 -0.358 0.557 ...
##  $ AbvBioAnnProd_2   : num  NA NA -1.452 -0.258 -0.358 ...
##  $ AbvBioAnnProd_3   : num  NA NA NA -1.452 -0.258 ...
##  $ noh020tot         : num  1.47099 -0.00364 0.77992 -0.16806 -0.90152 ...
##  $ noh020tot_1       : num  NA 1.47099 -0.00364 0.77992 -0.16806 ...
##  $ noh020tot_2       : num  NA NA 1.47099 -0.00364 0.77992 ...
##  $ noh020tot_3       : num  NA NA NA 1.47099 -0.00364 ...
##  $ invrichness       : num  1.2214 0.3054 0.7634 0.0763 -1.2977 ...
##  $ invrichness_1     : num  NA 1.2214 0.3054 0.7634 0.0763 ...
##  $ invrichness_2     : num  NA NA 1.221 0.305 0.763 ...
##  $ invrichness_3     : num  NA NA NA 1.221 0.305 ...
##  $ SummerPrecip.mm.  : num  0.299 0.265 -1.238 0.973 -1.225 ...
##  $ SummerPrecip.mm._1: num  NA 0.299 0.265 -1.238 0.973 ...
##  $ SummerPrecip.mm._2: num  NA NA 0.299 0.265 -1.238 ...
##  $ SummerPrecip.mm._3: num  NA NA NA 0.299 0.265 ...</code></pre>
<p>Next, we run the models, being sure to set up predictor variables (the <code>columns</code> argument) and the variable to be predicted (the <code>target_column</code> argument). By default, predictions are always for one step ahead. Note that one model includes only lagged observations of biomass, and the other model also includes precipitation:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb54-1" data-line-number="1">AB_columns &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">"AbvBioAnnProd"</span>, <span class="st">"AbvBioAnnProd_1"</span>, <span class="st">"AbvBioAnnProd_2"</span>, <span class="st">"AbvBioAnnProd_3"</span>)</a>
<a class="sourceLine" id="cb54-2" data-line-number="2">AB_output &lt;-<span class="st"> </span><span class="kw"><a href="../reference/block_lnlp.html">block_lnlp</a></span>(block_data, <span class="dt">lib =</span> composite_lib, <span class="dt">pred =</span> composite_pred, </a>
<a class="sourceLine" id="cb54-3" data-line-number="3">                        <span class="dt">columns =</span> AB_columns, <span class="dt">target_column =</span> <span class="st">"AbvBioAnnProd"</span>, </a>
<a class="sourceLine" id="cb54-4" data-line-number="4">                        <span class="dt">stats_only =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb54-5" data-line-number="5"></a>
<a class="sourceLine" id="cb54-6" data-line-number="6">Precip_columns &lt;-<span class="st"> </span><span class="kw">c</span>(AB_columns, <span class="st">"SummerPrecip.mm."</span>)</a>
<a class="sourceLine" id="cb54-7" data-line-number="7">Precip_output &lt;-<span class="st"> </span><span class="kw"><a href="../reference/block_lnlp.html">block_lnlp</a></span>(block_data, <span class="dt">lib =</span> composite_lib, <span class="dt">pred =</span> composite_pred, </a>
<a class="sourceLine" id="cb54-8" data-line-number="8">                            <span class="dt">columns =</span> Precip_columns, <span class="dt">target_column =</span> <span class="st">"AbvBioAnnProd"</span>, </a>
<a class="sourceLine" id="cb54-9" data-line-number="9">                            <span class="dt">stats_only =</span> <span class="ot">FALSE</span>)</a></code></pre></div>
<p>We examine model performance by comparing predicted vs. observed values:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb55-1" data-line-number="1">observed_AB &lt;-<span class="st"> </span>AB_output<span class="op">$</span>model_output[[<span class="dv">1</span>]]<span class="op">$</span>obs</a>
<a class="sourceLine" id="cb55-2" data-line-number="2">predicted_AB &lt;-<span class="st"> </span>AB_output<span class="op">$</span>model_output[[<span class="dv">1</span>]]<span class="op">$</span>pred</a>
<a class="sourceLine" id="cb55-3" data-line-number="3"></a>
<a class="sourceLine" id="cb55-4" data-line-number="4">observed_Precip &lt;-<span class="st"> </span>Precip_output<span class="op">$</span>model_output[[<span class="dv">1</span>]]<span class="op">$</span>obs</a>
<a class="sourceLine" id="cb55-5" data-line-number="5">predicted_Precip &lt;-<span class="st"> </span>Precip_output<span class="op">$</span>model_output[[<span class="dv">1</span>]]<span class="op">$</span>pred</a>
<a class="sourceLine" id="cb55-6" data-line-number="6"></a>
<a class="sourceLine" id="cb55-7" data-line-number="7">plot_range &lt;-<span class="st"> </span><span class="kw">range</span>(<span class="kw">c</span>(observed_AB, predicted_AB), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb55-8" data-line-number="8"><span class="kw">plot</span>(observed_AB, predicted_AB, <span class="dt">xlim =</span> plot_range, <span class="dt">ylim =</span> plot_range, </a>
<a class="sourceLine" id="cb55-9" data-line-number="9">     <span class="dt">xlab =</span> <span class="st">"Observed"</span>, <span class="dt">ylab =</span> <span class="st">"Predicted"</span>)</a>
<a class="sourceLine" id="cb55-10" data-line-number="10"><span class="kw">abline</span>(<span class="dt">a =</span> <span class="dv">0</span>, <span class="dt">b =</span> <span class="dv">1</span>, <span class="dt">lty =</span> <span class="dv">2</span>, <span class="dt">col =</span> <span class="st">"darkgrey"</span>, <span class="dt">lwd =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb55-11" data-line-number="11"><span class="kw">abline</span>(<span class="kw">lm</span>(predicted_AB <span class="op">~</span><span class="st"> </span>observed_AB), <span class="dt">col =</span> <span class="st">"black"</span>, <span class="dt">lty =</span> <span class="dv">3</span>, <span class="dt">lwd =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb55-12" data-line-number="12"></a>
<a class="sourceLine" id="cb55-13" data-line-number="13"><span class="kw">points</span>(observed_Precip, predicted_Precip, <span class="dt">pch =</span> <span class="dv">2</span>, <span class="dt">col =</span> <span class="st">"red"</span>)</a>
<a class="sourceLine" id="cb55-14" data-line-number="14"><span class="kw">abline</span>(<span class="kw">lm</span>(predicted_Precip <span class="op">~</span><span class="st"> </span>observed_Precip), <span class="dt">col =</span> <span class="st">"red"</span>, <span class="dt">lty =</span> <span class="dv">3</span>, <span class="dt">lwd =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb55-15" data-line-number="15"></a>
<a class="sourceLine" id="cb55-16" data-line-number="16"><span class="kw">legend</span>(<span class="st">"bottom"</span>, <span class="dt">legend =</span> <span class="kw">c</span>(<span class="kw">paste</span>(<span class="st">"(biomass alone) rho ="</span>, <span class="kw">round</span>(AB_output<span class="op">$</span>rho, <span class="dv">2</span>)), </a>
<a class="sourceLine" id="cb55-17" data-line-number="17">                             <span class="kw">paste</span>(<span class="st">"(biomass and prec.) rho ="</span>, <span class="kw">round</span>(Precip_output<span class="op">$</span>rho, <span class="dv">2</span>))), </a>
<a class="sourceLine" id="cb55-18" data-line-number="18">       <span class="dt">lty =</span> <span class="dv">3</span>, <span class="dt">lwd =</span> <span class="dv">2</span>, <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">"black"</span>, <span class="st">"red"</span>), <span class="dt">box.col =</span> <span class="ot">NA</span>, <span class="dt">xpd =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/block_lnlp%20on%20e120-1.png" width="384"></p>
<p>There is a marked improvement in forecast skill when including precipitation as a predictor, and the relationship between predicted and observed values falls closer to the 1:1 line (compare the red dashed line to the black dashed line). However, there is still a great deal of variability in biomass that is unexplained (<span class="math inline">\(R^2 = 0.48\)</span>).</p>
</div>
<div id="convergent-cross-mapping" class="section level3">
<h3 class="hasAnchor">
<a href="#convergent-cross-mapping" class="anchor"></a>Convergent Cross Mapping</h3>
<p>Finally, we can apply CCM to test for pairwise causal links among variables. For each individual test, we use the embedding dimension corresponding to the best embedding dimension of the variable used for reconstruction (i.e. the putative affected process). Recall we are primarily interested in testing whether the biomass of planted species or soil nitrogen concentration affects the dynamics of invading species.</p>
<p>First, we examine the relationship between invader richness and soil nitrate level:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb56-1" data-line-number="1">lib_sizes &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">seq</span>(<span class="dv">5</span>, <span class="dv">50</span>, <span class="dt">by =</span> <span class="dv">5</span>), <span class="kw">seq</span>(<span class="dv">55</span>, <span class="dv">230</span>, <span class="dt">by =</span> <span class="dv">20</span>))</a>
<a class="sourceLine" id="cb56-2" data-line-number="2"></a>
<a class="sourceLine" id="cb56-3" data-line-number="3">inv_xmap_no &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm.html">ccm</a></span>(composite_ts, <span class="dt">lib =</span> segments, <span class="dt">pred =</span> segments, </a>
<a class="sourceLine" id="cb56-4" data-line-number="4">                   <span class="dt">lib_column =</span> <span class="st">"invrichness"</span>, <span class="dt">target_column =</span> <span class="st">"noh020tot"</span>, </a>
<a class="sourceLine" id="cb56-5" data-line-number="5">                   <span class="dt">E =</span> best_E[<span class="st">"invrichness"</span>], <span class="dt">lib_sizes =</span> lib_sizes, </a>
<a class="sourceLine" id="cb56-6" data-line-number="6">                   <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb56-7" data-line-number="7">no_xmap_inv &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm.html">ccm</a></span>(composite_ts, <span class="dt">lib =</span> segments, <span class="dt">pred =</span> segments, </a>
<a class="sourceLine" id="cb56-8" data-line-number="8">                   <span class="dt">lib_column =</span> <span class="st">"noh020tot"</span>, <span class="dt">target_column =</span> <span class="st">"invrichness"</span>, </a>
<a class="sourceLine" id="cb56-9" data-line-number="9">                   <span class="dt">E =</span> best_E[<span class="st">"noh020tot"</span>], <span class="dt">lib_sizes =</span> lib_sizes, </a>
<a class="sourceLine" id="cb56-10" data-line-number="10">                   <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb56-11" data-line-number="11"></a>
<a class="sourceLine" id="cb56-12" data-line-number="12">inv_xmap_no_means &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm_means.html">ccm_means</a></span>(inv_xmap_no)</a>
<a class="sourceLine" id="cb56-13" data-line-number="13">no_xmap_inv_means &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm_means.html">ccm_means</a></span>(no_xmap_inv)</a>
<a class="sourceLine" id="cb56-14" data-line-number="14"></a>
<a class="sourceLine" id="cb56-15" data-line-number="15"><span class="kw">plot</span>(inv_xmap_no_means<span class="op">$</span>lib_size, <span class="kw">pmax</span>(<span class="dv">0</span>, inv_xmap_no_means<span class="op">$</span>rho), <span class="dt">type =</span> <span class="st">"l"</span>, </a>
<a class="sourceLine" id="cb56-16" data-line-number="16">     <span class="dt">xlab =</span> <span class="st">"Library Size"</span>, <span class="dt">ylab =</span> <span class="st">"Cross Map Skill (rho)"</span>, </a>
<a class="sourceLine" id="cb56-17" data-line-number="17">     <span class="dt">col =</span> <span class="st">"red"</span>, <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">0.15</span>), <span class="dt">lwd =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb56-18" data-line-number="18"><span class="kw">lines</span>(no_xmap_inv_means<span class="op">$</span>lib_size, <span class="kw">pmax</span>(<span class="dv">0</span>, no_xmap_inv_means<span class="op">$</span>rho), </a>
<a class="sourceLine" id="cb56-19" data-line-number="19">      <span class="dt">col =</span> <span class="st">"blue"</span>, <span class="dt">lwd =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb56-20" data-line-number="20"><span class="kw">legend</span>(<span class="dt">x =</span> <span class="st">"topleft"</span>, <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">"red"</span>, <span class="st">"blue"</span>), <span class="dt">lwd =</span> <span class="dv">2</span>, </a>
<a class="sourceLine" id="cb56-21" data-line-number="21">       <span class="dt">legend =</span> <span class="kw">c</span>(<span class="st">"Inv. Richness xmap Nitrate"</span>, <span class="st">"Nitrate xmap Inv. Richness"</span>), </a>
<a class="sourceLine" id="cb56-22" data-line-number="22">       <span class="dt">inset =</span> <span class="fl">0.02</span>, <span class="dt">bty =</span> <span class="st">"n"</span>, <span class="dt">cex =</span> <span class="fl">0.8</span>)</a>
<a class="sourceLine" id="cb56-23" data-line-number="23"><span class="kw">abline</span>(<span class="dt">h =</span> <span class="dv">0</span>, <span class="dt">lty =</span> <span class="dv">3</span>)</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/richness%20and%20nitrate-1.png" width="480"></p>
<p>And then repeat for the relationship between invader richness and biological productivity:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb57-1" data-line-number="1">inv_xmap_abv &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm.html">ccm</a></span>(composite_ts, <span class="dt">lib =</span> segments, <span class="dt">pred =</span> segments, </a>
<a class="sourceLine" id="cb57-2" data-line-number="2">                    <span class="dt">lib_column =</span> <span class="st">"invrichness"</span>, <span class="dt">target_column =</span> <span class="st">"AbvBioAnnProd"</span>, </a>
<a class="sourceLine" id="cb57-3" data-line-number="3">                    <span class="dt">E =</span> best_E[<span class="st">"invrichness"</span>], <span class="dt">lib_sizes =</span> lib_sizes, </a>
<a class="sourceLine" id="cb57-4" data-line-number="4">                    <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb57-5" data-line-number="5">abv_xmap_inv &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm.html">ccm</a></span>(composite_ts, <span class="dt">lib =</span> segments, <span class="dt">pred =</span> segments, </a>
<a class="sourceLine" id="cb57-6" data-line-number="6">                    <span class="dt">lib_column =</span> <span class="st">"AbvBioAnnProd"</span>, <span class="dt">target_column =</span> <span class="st">"invrichness"</span>, </a>
<a class="sourceLine" id="cb57-7" data-line-number="7">                    <span class="dt">E =</span> best_E[<span class="st">"AbvBioAnnProd"</span>], <span class="dt">lib_sizes =</span> lib_sizes, </a>
<a class="sourceLine" id="cb57-8" data-line-number="8">                    <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb57-9" data-line-number="9"></a>
<a class="sourceLine" id="cb57-10" data-line-number="10">inv_xmap_abv_means &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm_means.html">ccm_means</a></span>(inv_xmap_abv)</a>
<a class="sourceLine" id="cb57-11" data-line-number="11">abv_xmap_inv_means &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm_means.html">ccm_means</a></span>(abv_xmap_inv)</a>
<a class="sourceLine" id="cb57-12" data-line-number="12"></a>
<a class="sourceLine" id="cb57-13" data-line-number="13"><span class="kw">plot</span>(inv_xmap_abv_means<span class="op">$</span>lib_size, <span class="kw">pmax</span>(<span class="dv">0</span>, inv_xmap_abv_means<span class="op">$</span>rho), <span class="dt">type =</span> <span class="st">"l"</span>, </a>
<a class="sourceLine" id="cb57-14" data-line-number="14">     <span class="dt">xlab =</span> <span class="st">"Library Size"</span>, <span class="dt">ylab =</span> <span class="st">"Cross Map Skill (rho)"</span>, </a>
<a class="sourceLine" id="cb57-15" data-line-number="15">     <span class="dt">col =</span> <span class="st">"red"</span>, <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">0.4</span>), <span class="dt">lwd =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb57-16" data-line-number="16"><span class="kw">lines</span>(abv_xmap_inv_means<span class="op">$</span>lib_size, <span class="kw">pmax</span>(<span class="dv">0</span>, abv_xmap_inv_means<span class="op">$</span>rho),</a>
<a class="sourceLine" id="cb57-17" data-line-number="17">      <span class="dt">col =</span> <span class="st">"blue"</span>, <span class="dt">lwd =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb57-18" data-line-number="18"><span class="kw">legend</span>(<span class="dt">x =</span> <span class="st">"topleft"</span>, <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">"red"</span>, <span class="st">"blue"</span>), <span class="dt">lwd =</span> <span class="dv">2</span>, </a>
<a class="sourceLine" id="cb57-19" data-line-number="19">       <span class="dt">legend =</span> <span class="kw">c</span>(<span class="st">"Inv. Richness xmap Total Biomass"</span>, </a>
<a class="sourceLine" id="cb57-20" data-line-number="20">                  <span class="st">"Total Biomass xmap Inv. Richness"</span>), </a>
<a class="sourceLine" id="cb57-21" data-line-number="21">       <span class="dt">inset =</span> <span class="fl">0.02</span>, <span class="dt">bty =</span> <span class="st">"n"</span>, <span class="dt">cex =</span> <span class="fl">0.8</span>)</a>
<a class="sourceLine" id="cb57-22" data-line-number="22"></a>
<a class="sourceLine" id="cb57-23" data-line-number="23"><span class="kw">abline</span>(<span class="dt">h =</span> <span class="dv">0</span>, <span class="dt">lty =</span> <span class="dv">3</span>)</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/richness%20and%20biomass-1.png" width="480"></p>
<p>The first figure suggests that plot-level soil nitrate is causally forced by invader richness, while the reverse is not true. This is plausible, as the planted compositions are quite similar among experimental replicates, and fluctuations in soil nitrate may be largely indicative of minor variations due to transient populations of invading species before they can be weeded out. Thus, the effect of nitrate on invader richness may be minimal. However, recall from the S-map analysis that soil nitrate dynamics also appear linear. As such, a more detailed look into the relationship between nitrate and invader richness may be warranted, that also considers methods more appropriate for linear systems, such as Granger Causality <span class="citation">(1969)</span>.</p>
<p>The second figure indicates bidirectional forcing between invader richness and total biomass. Although we would normally expect <span class="math inline">\(\rho\)</span> to continue to increase with library length, the decrease here is not necessarily problematic. For the CCM analysis, we use a composite time series constructed from multiple plots with no more than 7 time points each. Consequently, the larger library sizes represent samples that contain multiple plots. The small decrease in <span class="math inline">\(\rho\)</span> at larger library sizes may therefore indicate heterogeneity in the causal effects among plots.</p>
<p>Overall, these results suggest that invader richness is influenced by the biomass of the planted community, with a somewhat weaker effect in the opposite direction, but that nitrate is influenced by invader dynamics without feedbacks. In contrast to existing hypotheses, this result indicates that in plots planted with 16 species, the planted community biomass itself directly inhibits invasion (e.g. through light limitation), rather than through an indirect effects on soil nitrate, as nitrate does not appear to affect invader richness (n.b. though recall that we are analyzing dynamics within only a single level of planted species richness).</p>
</div>
</div>
<div id="apple-blossom-thrips" class="section level2">
<h2 class="hasAnchor">
<a href="#apple-blossom-thrips" class="anchor"></a>Apple-Blossom Thrips</h2>
<p>Next, we re-examine the classic apple-blossom thrips (<em>Thrips imaginis</em>) time series from the Waite Institute in Australia <span class="citation">(Davidson and Andrewartha 1948a, 1948b)</span>. Seasonal outbreaks of thrips were observed to vary greatly in magnitude from year to year, with large outbreaks occurring simultaneously across space. This led to the hypothesis that regional-scale climatic factors were responsible for controlling the size of the seasonal outbreaks (what might now be called the Moran effect <span class="citation">(1953)</span>).</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="kw">data</span>(thrips_block)</a>
<a class="sourceLine" id="cb58-2" data-line-number="2"><span class="kw">str</span>(thrips_block)</a></code></pre></div>
<pre><code>## 'data.frame':    81 obs. of  6 variables:
##  $ Year           : int  1932 1932 1932 1932 1932 1932 1932 1932 1932 1933 ...
##  $ Month          : int  4 5 6 7 8 9 10 11 12 1 ...
##  $ Thrips_imaginis: num  4.5 23.4 17.8 4.4 3.3 ...
##  $ maxT_degC      : num  19.2 19.1 14.3 13.8 14.6 17.6 17.4 23.3 24.3 24.8 ...
##  $ Rain_mm        : num  140.1 53.7 134.1 89.9 92.2 ...
##  $ Season         : num  -0.5 -0.866 -1 -0.866 -0.5 0 0.5 0.866 1 0.866 ...</code></pre>
<p>The first data column, <code>Thrips_imaginis</code>, contains counts of <em>Thrips imaginis</em> obtained from the Global Population Dynamics Database (GPDD) <span class="citation">(NERC Centre for Population Biology 2010)</span>. <code>maxT_degC</code> is the mean maximum daily temperature (<span class="math inline">\(^\circ\)</span>C) taken over each month and <code>Rain_mm</code> is the monthly rainfall (mm), both from the Waite Institute. The final column, <code>Season</code>, is a simple annual sinusoid that peaks in December (the Austral summer) and acts as an indicator of season.</p>
<p>First, we plot the data.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb60-1" data-line-number="1">iso_date &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="kw">paste0</span>(thrips_block<span class="op">$</span>Year, <span class="st">"-"</span>, thrips_block<span class="op">$</span>Month, <span class="st">"-15"</span>))</a>
<a class="sourceLine" id="cb60-2" data-line-number="2"><span class="kw">plot</span>(iso_date, thrips_block<span class="op">$</span>Thrips_imaginis, <span class="dt">type =</span> <span class="st">"l"</span>, <span class="dt">col =</span> <span class="st">"green"</span>, <span class="dt">ylab =</span> <span class="st">"Thrips"</span>, <span class="dt">xlab =</span> <span class="st">""</span>)</a>
<a class="sourceLine" id="cb60-3" data-line-number="3"><span class="kw">plot</span>(iso_date, thrips_block<span class="op">$</span>maxT_degC, <span class="dt">type =</span> <span class="st">"l"</span>, <span class="dt">col =</span> <span class="st">"red"</span>, <span class="dt">ylab =</span> <span class="st">"maxT (oC)"</span>, <span class="dt">xlab =</span> <span class="st">""</span>)</a>
<a class="sourceLine" id="cb60-4" data-line-number="4"><span class="kw">plot</span>(iso_date, thrips_block<span class="op">$</span>Rain_mm, <span class="dt">type =</span> <span class="st">"l"</span>, <span class="dt">col =</span> <span class="st">"blue"</span>, <span class="dt">ylab =</span> <span class="st">"Rain (mm)"</span>, <span class="dt">xlab =</span> <span class="st">""</span>)</a>
<a class="sourceLine" id="cb60-5" data-line-number="5"><span class="kw">plot</span>(iso_date, thrips_block<span class="op">$</span>Season, <span class="dt">type =</span> <span class="st">"l"</span>, <span class="dt">col =</span> <span class="st">"magenta"</span>, <span class="dt">ylab =</span> <span class="st">"Season"</span>, <span class="dt">xlab =</span> <span class="st">""</span>)</a>
<a class="sourceLine" id="cb60-6" data-line-number="6"><span class="kw">mtext</span>(<span class="st">"Year"</span>, <span class="dt">side =</span> <span class="dv">1</span>, <span class="dt">outer =</span> <span class="ot">TRUE</span>, <span class="dt">line =</span> <span class="dv">1</span>)</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/thrips%20plot-1.png" width="576"></p>
<p>Note that all the time-series variables show marked seasonality.</p>
<div id="univariate-analysis" class="section level3">
<h3 class="hasAnchor">
<a href="#univariate-analysis" class="anchor"></a>Univariate Analysis</h3>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb61-1" data-line-number="1">ts &lt;-<span class="st"> </span>thrips_block<span class="op">$</span>Thrips_imaginis</a>
<a class="sourceLine" id="cb61-2" data-line-number="2">lib &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="kw">length</span>(ts))</a>
<a class="sourceLine" id="cb61-3" data-line-number="3">pred &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="kw">length</span>(ts))</a>
<a class="sourceLine" id="cb61-4" data-line-number="4">simplex_output &lt;-<span class="st"> </span><span class="kw"><a href="../reference/simplex.html">simplex</a></span>(ts, lib, pred, <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb61-5" data-line-number="5"><span class="kw">plot</span>(simplex_output<span class="op">$</span>E, simplex_output<span class="op">$</span>rho, <span class="dt">type =</span> <span class="st">"l"</span>,</a>
<a class="sourceLine" id="cb61-6" data-line-number="6">     <span class="dt">xlab =</span> <span class="st">"Embedding Dimension (E)"</span>, <span class="dt">ylab =</span> <span class="st">"Forecast Skill (rho)"</span>)</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/univariate%20thrips-1.png" width="480"></p>
<p>While there is an initial peak in forecast skill at <code>E = 4</code>, the maximum <span class="math inline">\(\rho\)</span> is at <code>E = 8</code>. This suggests that 4 and 8 are both practical embedding dimensions.</p>
<p>To test for nonlinearity, we again use S-maps, and test both <code>E = 4</code> and <code>E = 8</code> to verify that the result is robust to the choice of embedding dimension.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb62-1" data-line-number="1">smap_output &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">s_map</span>(ts, lib, pred, <span class="dt">E =</span> <span class="dv">4</span>, <span class="dt">silent =</span> <span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb62-2" data-line-number="2">                    <span class="kw">s_map</span>(ts, lib, pred, <span class="dt">E =</span> <span class="dv">8</span>, <span class="dt">silent =</span> <span class="ot">TRUE</span>))</a>
<a class="sourceLine" id="cb62-3" data-line-number="3"></a>
<a class="sourceLine" id="cb62-4" data-line-number="4"><span class="kw">plot</span>(smap_output[[<span class="dv">1</span>]]<span class="op">$</span>theta, smap_output[[<span class="dv">1</span>]]<span class="op">$</span>rho, <span class="dt">type =</span> <span class="st">"l"</span>, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">4</span>),</a>
<a class="sourceLine" id="cb62-5" data-line-number="5">     <span class="dt">xlab =</span> <span class="st">"Nonlinearity (theta)"</span>, <span class="dt">ylab =</span> <span class="st">"Forecast Skill (rho)"</span>)</a>
<a class="sourceLine" id="cb62-6" data-line-number="6"><span class="kw">plot</span>(smap_output[[<span class="dv">2</span>]]<span class="op">$</span>theta, smap_output[[<span class="dv">2</span>]]<span class="op">$</span>rho, <span class="dt">type =</span> <span class="st">"l"</span>, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">4</span>),</a>
<a class="sourceLine" id="cb62-7" data-line-number="7">     <span class="dt">xlab =</span> <span class="st">"Nonlinearity (theta)"</span>, <span class="dt">ylab =</span> <span class="st">"Forecast Skill (rho)"</span>)</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/smap%20for%20thrips-1.png" width="480"></p>
<p>The S-map results indicate nonlinearity in Thrips abundance, as the nonlinear models (<code>theta &gt; 0</code>) give substantially better predictions than the linear model (<code>theta = 0</code>). This suggests that, despite the strong seasonal dynamics, the Thrips population might not simply track the environment. To look more closely at the issue of seasonal drivers, we turn to convergent cross-mapping (CCM).</p>
</div>
<div id="seasonal-drivers" class="section level3">
<h3 class="hasAnchor">
<a href="#seasonal-drivers" class="anchor"></a>Seasonal Drivers</h3>
<p>Recall that there is a two-part criterion for CCM to be a rigorous test of causality: (1) cross map prediction skill is statistically significant when using the full time series as the library. (2) cross map prediction skill demonstrates convergence – prediction skill increases as more of the time series is used to reconstruct the attractor.</p>
<p>We first compute the cross map skill for each variable pair, using the full time series as the library. We use <code>E = 8</code> as it is the larger of the two values identified for Thrips abundance, and setting a fixed value reduces the chance of overfitting when cross mapping between all variable pairs.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb63-1" data-line-number="1">vars &lt;-<span class="st"> </span><span class="kw">colnames</span>(thrips_block[<span class="dv">3</span><span class="op">:</span><span class="dv">6</span>])</a>
<a class="sourceLine" id="cb63-2" data-line-number="2">n &lt;-<span class="st"> </span><span class="kw">NROW</span>(thrips_block)</a>
<a class="sourceLine" id="cb63-3" data-line-number="3">ccm_rho_matrix &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, <span class="dt">nrow =</span> <span class="kw">length</span>(vars), <span class="dt">ncol =</span> <span class="kw">length</span>(vars),</a>
<a class="sourceLine" id="cb63-4" data-line-number="4">                     <span class="dt">dimnames =</span> <span class="kw">list</span>(vars, vars))</a>
<a class="sourceLine" id="cb63-5" data-line-number="5"></a>
<a class="sourceLine" id="cb63-6" data-line-number="6"><span class="cf">for</span> (ccm_from <span class="cf">in</span> vars)</a>
<a class="sourceLine" id="cb63-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb63-8" data-line-number="8">    <span class="cf">for</span> (ccm_to <span class="cf">in</span> vars[vars <span class="op">!=</span><span class="st"> </span>ccm_from])</a>
<a class="sourceLine" id="cb63-9" data-line-number="9">    {</a>
<a class="sourceLine" id="cb63-10" data-line-number="10">        out_temp &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm.html">ccm</a></span>(thrips_block, <span class="dt">E =</span> <span class="dv">8</span>,</a>
<a class="sourceLine" id="cb63-11" data-line-number="11">                        <span class="dt">lib_column =</span> ccm_from, <span class="dt">target_column =</span> ccm_to,</a>
<a class="sourceLine" id="cb63-12" data-line-number="12">                        <span class="dt">lib_sizes =</span> n, <span class="dt">replace =</span> <span class="ot">FALSE</span>, <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb63-13" data-line-number="13">        ccm_rho_matrix[ccm_from, ccm_to] &lt;-<span class="st"> </span>out_temp<span class="op">$</span>rho</a>
<a class="sourceLine" id="cb63-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb63-15" data-line-number="15">}</a></code></pre></div>
<p>For comparison we compute the lagged cross-correlation, allowing lags of up to <span class="math inline">\(\pm 6\)</span> months.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb64-1" data-line-number="1">corr_matrix &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NA</span>, <span class="dt">dim =</span> <span class="kw">c</span>(<span class="kw">length</span>(vars), <span class="kw">length</span>(vars)),</a>
<a class="sourceLine" id="cb64-2" data-line-number="2">                     <span class="dt">dimnames =</span> <span class="kw">list</span>(vars, vars))</a>
<a class="sourceLine" id="cb64-3" data-line-number="3"></a>
<a class="sourceLine" id="cb64-4" data-line-number="4"><span class="cf">for</span> (ccm_from <span class="cf">in</span> vars)</a>
<a class="sourceLine" id="cb64-5" data-line-number="5">{</a>
<a class="sourceLine" id="cb64-6" data-line-number="6">    <span class="cf">for</span> (ccm_to <span class="cf">in</span> vars[vars <span class="op">!=</span><span class="st"> </span>ccm_from])</a>
<a class="sourceLine" id="cb64-7" data-line-number="7">    {</a>
<a class="sourceLine" id="cb64-8" data-line-number="8">        cf_temp &lt;-<span class="st"> </span><span class="kw">ccf</span>(thrips_block[, ccm_from], thrips_block[, ccm_to],</a>
<a class="sourceLine" id="cb64-9" data-line-number="9">                       <span class="dt">type =</span> <span class="st">"correlation"</span>, <span class="dt">lag.max =</span> <span class="dv">6</span>, <span class="dt">plot =</span> <span class="ot">FALSE</span>)<span class="op">$</span>acf</a>
<a class="sourceLine" id="cb64-10" data-line-number="10">        corr_matrix[ccm_from, ccm_to] &lt;-<span class="st"> </span><span class="kw">max</span>(<span class="kw">abs</span>(cf_temp))</a>
<a class="sourceLine" id="cb64-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb64-12" data-line-number="12">}</a></code></pre></div>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb65-1" data-line-number="1"><span class="kw">head</span>(ccm_rho_matrix)</a></code></pre></div>
<pre><code>##                 Thrips_imaginis maxT_degC Rain_mm Season
## Thrips_imaginis              NA      0.92    0.51   0.96
## maxT_degC                  0.60        NA    0.46   0.99
## Rain_mm                    0.43      0.82      NA   0.78
## Season                     0.56      0.96    0.39     NA</code></pre>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb67-1" data-line-number="1"><span class="kw">head</span>(corr_matrix)</a></code></pre></div>
<pre><code>##                 Thrips_imaginis maxT_degC Rain_mm Season
## Thrips_imaginis              NA      0.45    0.27   0.45
## maxT_degC                  0.45        NA    0.59   0.95
## Rain_mm                    0.27      0.59      NA   0.53
## Season                     0.45      0.95    0.53     NA</code></pre>
<p>Notice that the correlation between temperature and the seasonal indicator is extremely high. Thus, it is not surprising that the cross map results are also strong for the relationship between the seasonal variable and temperature, <span class="math inline">\(\rho = 0.96\)</span>. This makes interpretation more complicated, because we have to consider the possibility that cross mapping between temperature and Thrips abundance occurs because of the shared seasonality. In other words, we may observe high cross mapping <span class="math inline">\(\rho\)</span> between two variables with a seasonal cycle, even if there is no underlying causal mechanism.</p>
<div id="convergent-cross-mapping-1" class="section level4">
<h4 class="hasAnchor">
<a href="#convergent-cross-mapping-1" class="anchor"></a>Convergent Cross-Mapping</h4>
<p>With this in mind, we examine convergence in cross-map predictability, i.e. we compute <code>rho</code> as a function of library size <code>L</code>. We first look at Thrips and temperature.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb69-1" data-line-number="1">thrips_xmap_maxT &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm.html">ccm</a></span>(thrips_block, <span class="dt">E =</span> <span class="dv">8</span>, <span class="dt">random_libs =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb69-2" data-line-number="2">                        <span class="dt">lib_column =</span> <span class="st">"Thrips_imaginis"</span>, <span class="dt">target_column =</span> <span class="st">"maxT_degC"</span>,</a>
<a class="sourceLine" id="cb69-3" data-line-number="3">                        <span class="dt">lib_sizes =</span> <span class="kw">seq</span>(<span class="dv">10</span>, <span class="dv">75</span>, <span class="dt">by =</span> <span class="dv">5</span>), <span class="dt">num_samples =</span> <span class="dv">300</span>, </a>
<a class="sourceLine" id="cb69-4" data-line-number="4">                        <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb69-5" data-line-number="5">maxT_xmap_thrips &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm.html">ccm</a></span>(thrips_block, <span class="dt">E =</span> <span class="dv">8</span>, <span class="dt">random_libs =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb69-6" data-line-number="6">                        <span class="dt">lib_column =</span> <span class="st">"maxT_degC"</span>, <span class="dt">target_column =</span> <span class="st">"Thrips_imaginis"</span>,</a>
<a class="sourceLine" id="cb69-7" data-line-number="7">                        <span class="dt">lib_sizes =</span> <span class="kw">seq</span>(<span class="dv">10</span>, <span class="dv">75</span>, <span class="dt">by =</span> <span class="dv">5</span>), <span class="dt">num_samples =</span> <span class="dv">300</span>, </a>
<a class="sourceLine" id="cb69-8" data-line-number="8">                        <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb69-9" data-line-number="9"></a>
<a class="sourceLine" id="cb69-10" data-line-number="10">ccm_out &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw"><a href="../reference/ccm_means.html">ccm_means</a></span>(thrips_xmap_maxT), <span class="kw"><a href="../reference/ccm_means.html">ccm_means</a></span>(maxT_xmap_thrips))</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/ccm%20plot-1.png" width="480"></p>
<p>The magnitude of the cross-correlation between Thrips and temperature is shown as a black dashed line for comparison. We repeat the analysis for rainfall.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb70-1" data-line-number="1">thrips_xmap_Rain &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm.html">ccm</a></span>(thrips_block, <span class="dt">E =</span> <span class="dv">8</span>, <span class="dt">random_libs =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb70-2" data-line-number="2">                        <span class="dt">lib_column =</span> <span class="st">"Thrips_imaginis"</span>, <span class="dt">target_column =</span> <span class="st">"Rain_mm"</span>,</a>
<a class="sourceLine" id="cb70-3" data-line-number="3">                        <span class="dt">lib_sizes =</span> <span class="kw">seq</span>(<span class="dv">10</span>, <span class="dv">75</span>, <span class="dt">by =</span> <span class="dv">5</span>), <span class="dt">num_samples =</span> <span class="dv">300</span>, </a>
<a class="sourceLine" id="cb70-4" data-line-number="4">                        <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb70-5" data-line-number="5">Rain_xmap_thrips &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm.html">ccm</a></span>(thrips_block, <span class="dt">E =</span> <span class="dv">8</span>, <span class="dt">random_libs =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb70-6" data-line-number="6">                        <span class="dt">lib_column =</span> <span class="st">"Rain_mm"</span>, <span class="dt">target_column =</span> <span class="st">"Thrips_imaginis"</span>,</a>
<a class="sourceLine" id="cb70-7" data-line-number="7">                        <span class="dt">lib_sizes =</span> <span class="kw">seq</span>(<span class="dv">10</span>, <span class="dv">75</span>, <span class="dt">by =</span> <span class="dv">5</span>), <span class="dt">num_samples =</span> <span class="dv">300</span>, </a>
<a class="sourceLine" id="cb70-8" data-line-number="8">                        <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb70-9" data-line-number="9"></a>
<a class="sourceLine" id="cb70-10" data-line-number="10">ccm_out &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw"><a href="../reference/ccm_means.html">ccm_means</a></span>(thrips_xmap_Rain), <span class="kw"><a href="../reference/ccm_means.html">ccm_means</a></span>(Rain_xmap_thrips))</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/rainfall%20and%20thrips%20ccm%20plot-1.png" width="480"></p>
<p>And finally for the deterministic seasonal cycle.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb71-1" data-line-number="1">thrips_xmap_Season &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm.html">ccm</a></span>(thrips_block, <span class="dt">E =</span> <span class="dv">8</span>, <span class="dt">random_libs =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb71-2" data-line-number="2">                          <span class="dt">lib_column =</span> <span class="st">"Thrips_imaginis"</span>, <span class="dt">target_column =</span> <span class="st">"Season"</span>,</a>
<a class="sourceLine" id="cb71-3" data-line-number="3">                          <span class="dt">lib_sizes =</span> <span class="kw">seq</span>(<span class="dv">10</span>, <span class="dv">75</span>, <span class="dt">by =</span> <span class="dv">5</span>), <span class="dt">num_samples =</span> <span class="dv">300</span>, </a>
<a class="sourceLine" id="cb71-4" data-line-number="4">                          <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb71-5" data-line-number="5">Season_xmap_thrips &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm.html">ccm</a></span>(thrips_block, <span class="dt">E =</span> <span class="dv">8</span>, <span class="dt">random_libs =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb71-6" data-line-number="6">                          <span class="dt">lib_column =</span> <span class="st">"Season"</span>, <span class="dt">target_column =</span> <span class="st">"Thrips_imaginis"</span>,</a>
<a class="sourceLine" id="cb71-7" data-line-number="7">                          <span class="dt">lib_sizes =</span> <span class="kw">seq</span>(<span class="dv">10</span>, <span class="dv">75</span>, <span class="dt">by =</span> <span class="dv">5</span>), <span class="dt">num_samples =</span> <span class="dv">300</span>, </a>
<a class="sourceLine" id="cb71-8" data-line-number="8">                          <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb71-9" data-line-number="9"></a>
<a class="sourceLine" id="cb71-10" data-line-number="10">ccm_out &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw"><a href="../reference/ccm_means.html">ccm_means</a></span>(thrips_xmap_Season), <span class="kw"><a href="../reference/ccm_means.html">ccm_means</a></span>(Season_xmap_thrips))</a></code></pre></div>
<p><img src="rEDM-tutorial_files/figure-html/season%20and%20thrips%20ccm%20plot-1.png" width="480"></p>
<p>The results show clear evidence of convergence for Thrips cross mapping the climactic variables, with the cross map <span class="math inline">\(\rho\)</span> at the maximum library size exceeding cross-correlation between the variables.</p>
<p>However, we are still left with the conundrum that temperature and to a lesser extent, rainfall, are easily predicted from the seasonal cycle. In other words, the cross map results could be an artifact of shared seasonal forcing. Indeed, note that the pattern of results is similar for cross mapping between Thrips and an artificial indicator of the season in the figure above.</p>
<p>We can distinguish a true causal effect from shared seasonal forcing and a true causal effect by using a reasonable null model and testing if cross map skill obtained for <code>maxT_degC</code> and <code>Rain_mm</code> is significantly beyond what would be explained by the null model that has the same degree of shared seasonality. This hypothesis is readily tested using randomization tests based on surrogate data. The idea here is to generate surrogate time series with the same degree of shared seasonality. Cross mapping between the time series of actual Thrips abundance and the surrogates for climatic time series thus generates a null distribution for <span class="math inline">\(\rho\)</span>, against which the actual cross map <span class="math inline">\(\rho\)</span> value can be compared.</p>
</div>
<div id="seasonal-surrogate-test" class="section level4">
<h4 class="hasAnchor">
<a href="#seasonal-surrogate-test" class="anchor"></a>Seasonal Surrogate Test</h4>
<p>We use the <code><a href="../reference/make_surrogate_data.html">make_surrogate_data()</a></code> function to generate surrogate time series. Note that we select <code>method = "seasonal"</code> to produce surrogate time series with the same seasonal pattern, but with the anomalies shuffled. The <code>T_period</code> argument specifies the period for the seasonal signal; we use <code>12</code> as the data are monthly and the seasonality is annual.</p>
<p>Next we compute cross mapping between the true abundance and these surrogate environmental variables.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb72-1" data-line-number="1">num_surr &lt;-<span class="st"> </span><span class="dv">1000</span></a>
<a class="sourceLine" id="cb72-2" data-line-number="2">surr_maxT &lt;-<span class="st"> </span><span class="kw"><a href="../reference/make_surrogate_data.html">make_surrogate_data</a></span>(thrips_block<span class="op">$</span>maxT_degC, <span class="dt">method =</span> <span class="st">"seasonal"</span>,</a>
<a class="sourceLine" id="cb72-3" data-line-number="3">                                 <span class="dt">T_period =</span> <span class="dv">12</span>, <span class="dt">num_surr =</span> num_surr)</a>
<a class="sourceLine" id="cb72-4" data-line-number="4">surr_Rain &lt;-<span class="st"> </span><span class="kw"><a href="../reference/make_surrogate_data.html">make_surrogate_data</a></span>(thrips_block<span class="op">$</span>Rain_mm, <span class="dt">method =</span> <span class="st">"seasonal"</span>,</a>
<a class="sourceLine" id="cb72-5" data-line-number="5">                                 <span class="dt">T_period =</span> <span class="dv">12</span>, <span class="dt">num_surr =</span> num_surr)</a>
<a class="sourceLine" id="cb72-6" data-line-number="6"></a>
<a class="sourceLine" id="cb72-7" data-line-number="7">ccm_rho_surr &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">maxT =</span> <span class="kw">numeric</span>(num_surr), <span class="dt">Rain =</span> <span class="kw">numeric</span>(num_surr))</a>
<a class="sourceLine" id="cb72-8" data-line-number="8"></a>
<a class="sourceLine" id="cb72-9" data-line-number="9"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>num_surr) {</a>
<a class="sourceLine" id="cb72-10" data-line-number="10">    ccm_rho_surr<span class="op">$</span>maxT[i] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm.html">ccm</a></span>(<span class="kw">cbind</span>(thrips_block<span class="op">$</span>Thrips_imaginis, surr_maxT[,i]),</a>
<a class="sourceLine" id="cb72-11" data-line-number="11">                            <span class="dt">E =</span> <span class="dv">8</span>, <span class="dt">lib_column =</span> <span class="dv">1</span>, <span class="dt">target_column =</span> <span class="dv">2</span>,</a>
<a class="sourceLine" id="cb72-12" data-line-number="12">                            <span class="dt">lib_sizes =</span> <span class="kw">NROW</span>(thrips_block), <span class="dt">replace =</span> <span class="ot">FALSE</span>, </a>
<a class="sourceLine" id="cb72-13" data-line-number="13">                            <span class="dt">silent =</span> <span class="ot">TRUE</span>)<span class="op">$</span>rho</a>
<a class="sourceLine" id="cb72-14" data-line-number="14">    </a>
<a class="sourceLine" id="cb72-15" data-line-number="15">    ccm_rho_surr<span class="op">$</span>Rain[i] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ccm.html">ccm</a></span>(<span class="kw">cbind</span>(thrips_block<span class="op">$</span>Thrips_imaginis, surr_Rain[,i]),</a>
<a class="sourceLine" id="cb72-16" data-line-number="16">                            <span class="dt">E =</span> <span class="dv">8</span>, <span class="dt">lib_column =</span> <span class="dv">1</span>, <span class="dt">target_column =</span> <span class="dv">2</span>,</a>
<a class="sourceLine" id="cb72-17" data-line-number="17">                            <span class="dt">lib_sizes =</span> <span class="kw">NROW</span>(thrips_block), <span class="dt">replace =</span> <span class="ot">FALSE</span>, </a>
<a class="sourceLine" id="cb72-18" data-line-number="18">                            <span class="dt">silent =</span> <span class="ot">TRUE</span>)<span class="op">$</span>rho</a>
<a class="sourceLine" id="cb72-19" data-line-number="19">}</a></code></pre></div>
<p>These cross map values form a null distribution. We can then estimate a <span class="math inline">\(p\)</span> value for rejecting the null hypothesis that cross map <span class="math inline">\(\rho\)</span> is driven by the mutual seasonality.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb73-1" data-line-number="1">(<span class="kw">sum</span>(ccm_rho_matrix[<span class="st">'Thrips_imaginis'</span>, <span class="st">'Rain_mm'</span>] <span class="op">&lt;</span><span class="st"> </span>ccm_rho_surr<span class="op">$</span>Rain) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>) <span class="op">/</span></a>
<a class="sourceLine" id="cb73-2" data-line-number="2"><span class="st">    </span>(<span class="kw">length</span>(ccm_rho_surr<span class="op">$</span>Rain) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)</a></code></pre></div>
<pre><code>## [1] 0.041</code></pre>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb75-1" data-line-number="1">(<span class="kw">sum</span>(ccm_rho_matrix[<span class="st">'Thrips_imaginis'</span>, <span class="st">'maxT_degC'</span>] <span class="op">&lt;</span><span class="st"> </span>ccm_rho_surr<span class="op">$</span>maxT) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>) <span class="op">/</span></a>
<a class="sourceLine" id="cb75-2" data-line-number="2"><span class="st">    </span>(<span class="kw">length</span>(ccm_rho_surr<span class="op">$</span>maxT) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)</a></code></pre></div>
<pre><code>## [1] 0.18</code></pre>
<p>In both cases, the cross map skill that we measure for the real time series is better than the median expectation under the null hypothesis. For rainfall, the effect is significant based on the common threshold of <span class="math inline">\(p &lt; 0.05\)</span>. Howover, cross mapping between Thrips abundance and temperature is non-significant, which could be due to the high correlation between maximum daily temperature and the seasonal cycle. In other words, the actual time series for <code>maxT_degC</code> is already strongly periodic, and it is difficult to detect a causal signal on top of the seasonal cycle. Using higher frequency data or spatially resolved replicates (e.g. local temperature and local population counts) could help to enhance detectability under such circumstances.</p>
</div>
</div>
</div>
</div>
<div id="technical-details" class="section level1">
<h1 class="hasAnchor">
<a href="#technical-details" class="anchor"></a>Technical Details</h1>
<div id="data-input" class="section level2">
<h2 class="hasAnchor">
<a href="#data-input" class="anchor"></a>Data Input</h2>
<p>The <strong>rEDM</strong> functions are designed to accept data in common R data formats, namely vectors, matrices, and data.frames. Depending on the specific function, one or the other data type is preferred. Please see the documentation associated with individual functions for more details.</p>
<p>Missing data can be recorded using either of the standard <code>NA</code> or <code>NaN</code> values. The program will automatically ignore such missing values when appropriate. For instance, simplex projection will not select nearest neighbors if any of the state vector coordinates is missing or if the corresponding target value is missing.</p>
<p>Note that when there is no observed target value, it is still possible to make a prediction if the corresponding predictors have no missing values. Thus, it is possible to use the software to forecast from an observed state into an unobserved future. This can be done by substituting <code>NA</code> or <code>NaN</code> for unknown future values. However, be aware that the performance metrics are computed in a way that ignore suchs predictions (since there is nothing to compare against). Thus, the forecast statistics (e.g., <code>rho</code>, <code>MAE</code>, <code>RMSE</code>) may be computed based on fewer predictions than those actually made by the software.</p>
</div>
<div id="general-parameters" class="section level2">
<h2 class="hasAnchor">
<a href="#general-parameters" class="anchor"></a>General Parameters</h2>
<p>Many of the functions in <strong>rEDM</strong> are designed around the same prediction engine, and so share many of the same parameters. Please see the documentation associated with individual functions to verify which parameters are applicable as well as the default values (which can change from function to function)</p>
<ul>
<li>
<code>lib</code>
<ul>
<li>a 2-column matrix (or 2-element vector) where each row specifies the portions of the time series to use for attractor reconstruction (i.e., which reconstructed states can be selected as nearest neighbors)</li>
<li>e.g., <code>(1, n)</code> specifies that the first n <em>rows</em> (from 1 to n) of data are a contiguous time series block, each point of which can be used to construct state vectors</li>
<li>by default, <code>lib</code> uses the entire input as a single contiguous segment</li>
</ul>
</li>
<li>
<code>pred</code>
<ul>
<li>(same format as <code>lib</code>, but specifes the portions of the time series to make predictions for)</li>
</ul>
</li>
<li>
<code>norm_type</code>
<ul>
<li>
<code>"L2 norm"</code> (default) or <code>"L1 norm"</code>: specifies which distance metric to use when doing calculations</li>
<li>
<code>"L2 norm"</code> is the standard Euclidean distance, where the distance between a vector <span class="math inline">\(\mathbf{x} = \left(x_1, x_2, \dots, x_n \right)\)</span> and <span class="math inline">\(\mathbf{y} = \left( y_1, y_2, \dots, y_n \right)\)</span> is computed as <span class="math inline">\(\sqrt{(x_1 - y_1)^2 + (x_2 - y_2)^2 + \dots + (x_n - y_n)^2}\)</span>.</li>
<li>
<code>"L1 norm"</code> is the Manhattan norm (also known as taxicab distance), where the distance between a vector <span class="math inline">\(\mathbf{x} = \left( x_1, x_2, \dots, x_n \right)\)</span> and <span class="math inline">\(\mathbf{y} = \left( y_1, y_2, \dots, y_n \right)\)</span> is computed as <span class="math inline">\(|x_1 - y_1| + |x_2 - y_2| + \dots + |x_n - y_n|\)</span>.</li>
<li>
<code>"P norm"</code> is the generalization of the L1 and L2 norms which adds a parameter <span class="math inline">\(P\)</span> as the exponent: the distance between a vector <span class="math inline">\(\mathbf{x} = \left( x_1, x_2, \dots, x_n \right)\)</span> and <span class="math inline">\(\mathbf{y} = \left(y_1, y_2, \dots, y_n \right)\)</span> is computed as <span class="math inline">\({\left(\left|x_1 - y_1\right|^P + \left|x_2 - y_2\right|^P + \dots + \left|x_n - y_n\right|^P\right)^{1/P}}\)</span>.</li>
</ul>
</li>
<li>
<code>P</code>
<ul>
<li>the exponent for the “P norm” (and otherwise ignored)</li>
</ul>
</li>
<li>
<code>E</code>
<ul>
<li>the embedding dimension to use for time delay embedding</li>
</ul>
</li>
<li>
<code>tau</code>
<ul>
<li>the lag to use for time delay embedding</li>
<li>by default, <code>tau</code> is set to <code>1</code>
</li>
</ul>
</li>
<li>
<code>tp</code>
<ul>
<li>the prediction horizon (how many steps ahead to make forecasts)</li>
<li>negative values will also work</li>
<li>by default, <code>tp</code> is set to <code>1</code> for forecasting functions, and <code>0</code> for cross mapping</li>
</ul>
</li>
<li>
<code>num_neighbors</code>
<ul>
<li>the number of neighbors to use</li>
<li>
<code>"e+1"</code>, <code>"E+1"</code>, <code>"e + 1"</code>, and <code>"E + 1"</code> will all peg this parameter to be <code>E+1</code> for each run</li>
<li>values less than 1 will use all possible neighbors</li>
</ul>
</li>
<li>
<code>theta</code>
<ul>
<li>the nonlinear tuning parameter (for use with S-maps) that adjusts how distance is factored into computation of the local linear map (<code>0</code> corresponds to a globally linear map, while values greater than 0 correspond to nonlinear models where the local linear map changes as a function of state-space)</li>
</ul>
</li>
<li>
<code>stats_only</code>
<ul>
<li>
<code>TRUE</code> (default) or <code>FALSE</code>: specifies whether the output should just contain statistics of the predictions, or also include all the predictions that were made</li>
<li>if enabled, adds a <code>model_output</code> list-column, which contains the time index, observed values, predictions, and variance of predictions for each model</li>
</ul>
</li>
<li>
<code>exclusion_radius</code>
<ul>
<li>
<code>exclusion_radius</code> sets the threshold whereby all vectors with time indices too close to the predictee will be excluded from being considered nearest neighbors</li>
<li>e.g., <code>1</code> means that vectors must have an associated <strong>time index</strong> more than 1 away from potential nearest neighbors</li>
<li>by default, <code>exclusion_radius</code> is set to <code>NULL</code> (turning this filtering off)</li>
</ul>
</li>
<li>
<code>epsilon</code>
<ul>
<li>
<code>epsilon</code> sets the threshold whereby all vectors with distance too far away from the predictee will be excluded from being considered nearest neighbors</li>
<li>e.g., <code>2</code> means that vectors must have be within a <strong>distance</strong> of 2 from potential nearest neighbors</li>
<li>by default, <code>epsilon</code> is set to <code>NULL</code> (turning this filtering off)</li>
</ul>
</li>
<li>
<code>silent</code>
<ul>
<li>
<code>TRUE</code> or <code>FALSE</code> (default): specifies whether to suppress warning messages from being printed to the R console</li>
</ul>
</li>
<li>
<code>save_smap_coefficients</code>
<ul>
<li>
<code>TRUE</code> or <code>FALSE</code> (default): specifies whether to include a data.frame of S-map coefficients with the output</li>
<li>(note that setting this to <code>TRUE</code> forces the full output as if <code>stats_only = FALSE</code>)</li>
<li>if enabled, adds a <code>smap_coefficients</code> list-column, which contains the s-map coefficients; and a <code>smap_coefficient_covariance</code> list-column, which contains the covariance matrices for the s-map coefficients.</li>
</ul>
</li>
</ul>
<p>The Gaussian Process based functions, (<code><a href="../reference/tde_gp.html">tde_gp()</a></code> and <code><a href="../reference/block_gp.html">block_gp()</a></code>), have a few additional parameters specific to the GP methods:</p>
<ul>
<li>
<code>phi</code>
<ul>
<li>the length-scale parameter (how wiggly the function is in state-space)</li>
</ul>
</li>
<li>
<code>v_e</code>
<ul>
<li>the noise-variance parameter (the variance of noise on top of the outputs of the GP)</li>
</ul>
</li>
<li>
<code>eta</code>
<ul>
<li>the signal-variance parameter (the variance of the deterministic skeleton of the GP)</li>
</ul>
</li>
<li>
<code>fit_params</code>
<ul>
<li>
<code>TRUE</code> (default) or <code>FALSE</code>: specifies whether to fit the above parameters over the <code>lib</code> portion of the data, or use the parameters as given</li>
</ul>
</li>
<li>
<code>save_covariance_matrix</code>
<ul>
<li>
<code>TRUE</code> or <code>FALSE</code> (default): specifies whether to include a matrix for the covariance between predictions</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="acknowledgements" class="section level1">
<h1 class="hasAnchor">
<a href="#acknowledgements" class="anchor"></a>Acknowledgements</h1>
<p><strong>rEDM</strong> is the latest incarnation of EDM code. Past versions have been developed by George Sugihara, Alan Trombla, Richard Penner, Victor Wong, Martin Casdagli, Jerome Cartagena, Mohsen Azarbayejani, Ava Pierce, Jennifer Trezzo, and Hao Ye.</p>
<p>We thank Jun Cai, Jane Cowles, Yair Daon, Andrew Edwards, Oliver Keyes, James Stagge, Masayuki Ushio, and Ethan White, for their suggestions and contributions to the package and its documentation.</p>
<p>Package development and its documentation were supported by a Gordon and Betty Moore Foundation Data-Driven Discovery Initiative through Grant GBMF4563 (to Ethan P. White), NSF grant DEB-1655203 (GS), NSF grant DBI-1667584 (GS), U.S. Department of Defense Strategic Environmental Research and Development Program 15 RC-2509 (GS), Lenfest Ocean Program award 00028335 (GS), the Deutsche Bank-Jameson Complexity Studies Fund (GS), the Sugihara Family Trust (GS), the Leslie and John McQuown Gift and the McQuown Chair in Natural Sciences, UCSD (GS).</p>
<p>Data collection for the Cedar Creek LTER was funded by NSF grant DEB-9411972 (to G. David Tilman), DEB-0080382 (to G. David Tilman), DEB-0620652 (to G. David Tilman), and DEB-1234162 (to Eric Seabloom).</p>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h1>
<div id="refs" class="references">
<div id="ref-Casdagli_1991">
<p>Casdagli, M., S. Eubank, J. Farmer, and J. Gibson. 1991. State space reconstruction in the presence of noise. Physica D: Nonlinear Phenomena 51:52–98.</p>
</div>
<div id="ref-Clark_2015">
<p>Clark, A. T., H. Ye, F. Isbell, E. R. Deyle, J. Cowles, D. Tilman, and G. Sugihara. 2015. Spatial ’convergent cross mapping’ to detect causal relationships from short time-series. Ecology 96:1175–1181.</p>
</div>
<div id="ref-Davidson_1948">
<p>Davidson, J., and H. G. Andrewartha. 1948a. Annual trends in a natural population of <em>Thrips imaginis</em> (Thysanoptera). Journal of Animal Ecology 17:193–199.</p>
</div>
<div id="ref-Davidson_1948a">
<p>Davidson, J., and H. G. Andrewartha. 1948b. The influence of rainfall, evaporation and atmospheric temperature on fluctuations in the size of a natural population of <em>Thrips imaginis</em> (Thysanoptera). Journal of Animal Ecology 17:200–222.</p>
</div>
<div id="ref-Deyle_2016">
<p>Deyle, E. R., R. M. May, S. B. Munch, and G. Sugihara. 2016. Tracking and forecasting ecosystem interactions in real time. Proceedings of the Royal Society of London B 283.</p>
</div>
<div id="ref-Deyle_2011">
<p>Deyle, E. R., and G. Sugihara. 2011. Generalized theorems for nonlinear state space reconstruction. PLoS ONE 6:e18295.</p>
</div>
<div id="ref-Dixon_1999">
<p>Dixon, P. A., M. Milicich, and G. Sugihara. 1999. Episodic fluctuations in larval supply. Science 283:1528–1530.</p>
</div>
<div id="ref-Fargione_2005">
<p>Fargione, J. E., and D. Tilman. 2005. Diversity decreases invasion via both sampling and complementarity effects. Ecology Letters 8:604–611.</p>
</div>
<div id="ref-Fisher_1915">
<p>Fisher, R. A. 1915. Frequency distribution of the values of the correlation coefficient in samples from an indefinitely large population. Biometrika 10:507–521.</p>
</div>
<div id="ref-Granger_1969">
<p>Granger, C. 1969. Investigating causal relations by econometric models and cross-spectral methods. Econometrica 37:424–438.</p>
</div>
<div id="ref-Hsieh_2008">
<p>Hsieh, C.-H., C. Anderson, and G. Sugihara. 2008. Extending nonlinear analysis to short ecological time series. The American Naturalist 171:71–80.</p>
</div>
<div id="ref-Lorenz_1963">
<p>Lorenz, E. N. 1963. Deterministic nonperiodic flow. Journal of the Atmospheric Sciences 20:130–141.</p>
</div>
<div id="ref-Moran_1953">
<p>Moran, P. A. P. 1953. The statistical analysis of the canadian lynx cycle ii. Synchronization and meteorology. Australian Journal of Zoology:291–298.</p>
</div>
<div id="ref-NERC-Centre-for-Population-Biology_2010">
<p>NERC Centre for Population Biology, I. C. 2010. The global population dynamics database version 2.</p>
</div>
<div id="ref-Sauer_1991">
<p>Sauer, T., J. A. Yorke, and M. Casdagli. 1991. Embedology. Journal of Statistical Physics 65:579–616.</p>
</div>
<div id="ref-Sugihara_1994">
<p>Sugihara, G. 1994. Nonlinear forecasting for the classification of natural time series. Philosophical Transactions: Physical Sciences and Engineering 348:477–495.</p>
</div>
<div id="ref-Sugihara_1990">
<p>Sugihara, G., and R. M. May. 1990. Nonlinear forecasting as a way of distinguishing chaos from measurement error in time series. Nature 344:734–741.</p>
</div>
<div id="ref-Sugihara_2012">
<p>Sugihara, G., R. May, H. Ye, C.-H. Hsieh, E. Deyle, M. Fogarty, and S. Munch. 2012. Detecting causality in complex ecosystems. Science 338:496–500.</p>
</div>
<div id="ref-Takens_1981">
<p>Takens, F. 1981. Detecting strange attractors in turbulence. Dynamical Systems and Turbulence, Lecture Notes in Mathematics 898:366–381.</p>
</div>
<div id="ref-Tilman_1997">
<p>Tilman, D., J. Knops, D. Wedin, P. Reich, M. Ritchie, and E. Siemann. 1997. The influence of functional diversity and composition on ecosystem processes. Science 277:1300–1302.</p>
</div>
<div id="ref-Ye_2015a">
<p>Ye, H., E. R. Deyle, L. J. Gilarranz, and G. Sugihara. 2015. Distinguishing time-delayed causal interactions using convergent cross mapping. Scientific Reports 5:14750.</p>
</div>
<div id="ref-Ye_2016">
<p>Ye, H., and G. Sugihara. 2016. Information leverage in interconnected ecosystems: Overcoming the curse of dimensionality. Science 353:922–925.</p>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#abstract">Abstract</a></li>
      <li>
<a href="#introduction">Introduction</a><ul class="nav nav-pills nav-stacked">
<li><a href="#installation">Installation</a></li>
      </ul>
</li>
      <li>
<a href="#empirical-dynamic-modeling">Empirical Dynamic Modeling</a><ul class="nav nav-pills nav-stacked">
<li><a href="#time-series-as-observations-of-a-dynamic-system">Time Series as Observations of a Dynamic System</a></li>
      <li><a href="#attractor-reconstruction-takens-theorem">Attractor Reconstruction / Takens’ Theorem</a></li>
      </ul>
</li>
      <li>
<a href="#edm-examples">EDM Examples</a><ul class="nav nav-pills nav-stacked">
<li><a href="#nearest-neighbor-forecasting-using-simplex-projection">Nearest Neighbor Forecasting using Simplex Projection</a></li>
      <li><a href="#prediction-decay">Prediction Decay</a></li>
      <li><a href="#identifying-nonlinearity">Identifying Nonlinearity</a></li>
      <li><a href="#generalized-takenss-theorem">Generalized Takens’s Theorem</a></li>
      <li><a href="#s-map-coefficients">S-map Coefficients</a></li>
      <li><a href="#gaussian-process">Gaussian Process</a></li>
      <li><a href="#multiview-embedding">Multiview Embedding</a></li>
      <li><a href="#causality-inference-and-cross-mapping">Causality Inference and Cross Mapping</a></li>
      <li><a href="#convergent-cross-mapping-ccm">Convergent Cross Mapping (CCM)</a></li>
      <li><a href="#time-delays-with-ccm">Time Delays with CCM</a></li>
      </ul>
</li>
      <li>
<a href="#real-data-examples">Real Data Examples</a><ul class="nav nav-pills nav-stacked">
<li><a href="#community-productivity-and-invasibility">Community Productivity and Invasibility</a></li>
      <li><a href="#apple-blossom-thrips">Apple-Blossom Thrips</a></li>
      </ul>
</li>
      <li>
<a href="#technical-details">Technical Details</a><ul class="nav nav-pills nav-stacked">
<li><a href="#data-input">Data Input</a></li>
      <li><a href="#general-parameters">General Parameters</a></li>
      </ul>
</li>
      <li><a href="#acknowledgements">Acknowledgements</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Hao Ye, Adam Clark, Ethan Deyle, Steve Munch.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
